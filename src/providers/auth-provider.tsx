/* eslint-disable @typescript-eslint/no-unused-vars */`n `n/* eslint-disable @typescript-eslint/no-explicit-any */`n"use client";`n`nimport {`n  Dialog,`n  DialogContent,`n  DialogHeader,`n  DialogTitle,`n} from "@/components/ui/dialog";`nimport { Button } from "@/components/ui/button";`nimport { Alert, AlertDescription } from "@/components/ui/alert";`nimport {`n  checkUserRegistered as checkUserRegistration,`n  createUserAccountTransaction,`n  getUserFlowBalance,`n  getUserProfile,`n} from "@/lib/flow-wager-scripts";`nimport flowConfig from "@/lib/flow/config";`nimport { supabase } from "@/utils/supabase/client";`nimport * as fcl from "@onflow/fcl";`nimport React, {`n  ReactNode,`n  createContext,`n  useCallback,`n  useContext,`n  useEffect,`n  useRef,`n  useState,`n} from "react";`nimport { toast } from "sonner";`nimport { Loader2, AlertTriangle, Database, Circle as Sync, CheckCircle } from "lucide-react";`n`ninterface User {`n  addr: string | null;`n  cid: string | null;`n  loggedIn: boolean;`n  services: any[];`n}`n`ninterface AuthContextType {`n  user: User | null;`n  isLoading: boolean;`n  login: () => Promise<void>;`n  logout: () => Promise<void>;`n  authenticate: () => Promise<void>;`n  unauthenticate: () => Promise<void>;`n  isAuthenticated: boolean;`n  walletAddress: string | null;`n  sessionTimeRemaining: number;`n  balance: string;`n  isLoadingBalance: boolean;`n  balanceError: string | null;`n  refreshBalance: () => Promise<void>;`n  syncUserToSupabase: () => Promise<void>;`n  needsSupabaseSync: boolean;`n  isSyncing: boolean;`n}`n`ninterface AuthProviderProps {`n  children: ReactNode;`n}`n`nconst AuthContext = createContext<AuthContextType | undefined>(undefined);`n`nconst SESSION_TIMEOUT = 6 * 60 * 60 * 1000; // 6 hours in milliseconds`nconst SESSION_CHECK_INTERVAL = 60 * 1000; // Check every minute`nconst BALANCE_REFRESH_INTERVAL = 30 * 1000; // Refresh balance every 30 seconds`nconst SESSION_STORAGE_KEY = "flow_auth_session";`n`nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {`n  const [user, setUser] = useState<User | null>(null);`n  const [isLoading, setIsLoading] = useState(true);`n  const [sessionTimeRemaining, setSessionTimeRemaining] = useState<number>(0);`n  const [balance, setBalance] = useState<string>("0.00");`n  const [isLoadingBalance, setIsLoadingBalance] = useState<boolean>(false);`n  const [balanceError, setBalanceError] = useState<string | null>(null);`n`n  // New states for Supabase sync detection`n  const [needsSupabaseSync, setNeedsSupabaseSync] = useState<boolean>(false);`n  const [isSyncing, setIsSyncing] = useState<boolean>(false);`n  const [showSyncModal, setShowSyncModal] = useState<boolean>(false);`n`n  const sessionTimeoutRef = useRef<NodeJS.Timeout | null>(null);`n  const sessionCheckIntervalRef = useRef<NodeJS.Timeout | null>(null);`n  const balanceIntervalRef = useRef<NodeJS.Timeout | null>(null);`n`n  // Onboarding modal state`n  const [showOnboarding, setShowOnboarding] = useState(false);`n  const [onboardingUsername, setOnboardingUsername] = useState("");`n  const [onboardingDisplayName, setOnboardingDisplayName] = useState("");`n  const [onboardingBio, setOnboardingBio] = useState("");`n  const [onboardingError, setOnboardingError] = useState<string>("");`n  const [isCreatingAccount, setIsCreatingAccount] = useState(false);`n`n  const fetchBalance = useCallback(async (address: string) => {`n    if (!address) return;`n`n    setIsLoadingBalance(true);`n    setBalanceError(null);`n`n    try {`n      const userBalance = await fcl.query({`n        cadence: await getUserFlowBalance(),`n        args: (arg, t) => [arg(address, t.Address)],`n      });`n`n      setBalance(parseFloat(userBalance.toString()).toFixed(2));`n    } catch (error) {`n      console.error("Error fetching user balance:", error);`n      setBalanceError("Failed to fetch balance");`n      setBalance("0.00");`n    } finally {`n      setIsLoadingBalance(false);`n    }`n  }, []);`n`n  const refreshBalance = useCallback(async () => {`n    if (user?.addr) {`n      await fetchBalance(user.addr);`n    }`n  }, [user?.addr, fetchBalance]);`n`n  const startBalanceMonitoring = useCallback(`n    (address: string) => {`n      if (balanceIntervalRef.current) {`n        clearInterval(balanceIntervalRef.current);`n      }`n`n      fetchBalance(address);`n`n      balanceIntervalRef.current = setInterval(() => {`n        fetchBalance(address);`n      }, BALANCE_REFRESH_INTERVAL);`n    },`n    [fetchBalance]`n  );`n`n  const stopBalanceMonitoring = useCallback(() => {`n    if (balanceIntervalRef.current) {`n      clearInterval(balanceIntervalRef.current);`n      balanceIntervalRef.current = null;`n    }`n    setBalance("0.00");`n    setBalanceError(null);`n  }, []);`n`n  const clearTimers = useCallback(() => {`n    if (sessionTimeoutRef.current) {`n      clearTimeout(sessionTimeoutRef.current);`n      sessionTimeoutRef.current = null;`n    }`n    if (sessionCheckIntervalRef.current) {`n      clearInterval(sessionCheckIntervalRef.current);`n      sessionCheckIntervalRef.current = null;`n    }`n    if (balanceIntervalRef.current) {`n      clearInterval(balanceIntervalRef.current);`n      balanceIntervalRef.current = null;`n    }`n  }, []);`n`n  const saveSessionTimestamp = useCallback(() => {`n    const timestamp = Date.now();`n    sessionStorage.setItem(SESSION_STORAGE_KEY, timestamp.toString());`n  }, []);`n`n  const getSessionTimestamp = useCallback(() => {`n    const timestamp = sessionStorage.getItem(SESSION_STORAGE_KEY);`n    return timestamp ? parseInt(timestamp, 10) : null;`n  }, []);`n`n  const clearSessionData = useCallback(() => {`n    sessionStorage.removeItem(SESSION_STORAGE_KEY);`n  }, []);`n`n  const isSessionExpired = useCallback(() => {`n    const sessionStart = getSessionTimestamp();`n    if (!sessionStart) return false;`n`n    const now = Date.now();`n    const elapsed = now - sessionStart;`n    return elapsed > SESSION_TIMEOUT;`n  }, [getSessionTimestamp]);`n`n  const getTimeRemaining = useCallback(() => {`n    const sessionStart = getSessionTimestamp();`n    if (!sessionStart) return 0;`n`n    const now = Date.now();`n    const elapsed = now - sessionStart;`n    const remaining = SESSION_TIMEOUT - elapsed;`n    return Math.max(0, remaining);`n  }, [getSessionTimestamp]);`n`n  const autoLogout = useCallback(async () => {`n    console.log("Session expired - automatically logging out user");`n    try {`n      await fcl.unauthenticate();`n      setUser(null);`n      clearSessionData();`n      clearTimers();`n      stopBalanceMonitoring();`n      setShowOnboarding(false);`n    } catch (error) {`n      console.error("Auto logout failed:", error);`n    }`n  }, [clearSessionData, clearTimers, stopBalanceMonitoring]);`n`n  const startSessionMonitoring = useCallback(() => {`n    clearTimers();`n`n    const timeRemaining = getTimeRemaining();`n`n    sessionTimeoutRef.current = setTimeout(() => {`n      autoLogout();`n    }, timeRemaining);`n`n    sessionCheckIntervalRef.current = setInterval(() => {`n      const remaining = getTimeRemaining();`n      setSessionTimeRemaining(remaining);`n`n      if (remaining <= 0) {`n        autoLogout();`n      }`n    }, SESSION_CHECK_INTERVAL);`n`n    setSessionTimeRemaining(timeRemaining);`n  }, [getTimeRemaining, autoLogout, clearTimers]);`n`n  const resetSessionActivity = useCallback(() => {`n    if (user?.loggedIn) {`n      saveSessionTimestamp();`n      startSessionMonitoring();`n    }`n  }, [user?.loggedIn, saveSessionTimestamp, startSessionMonitoring]);`n`n  // Enhanced function to check if user needs Supabase sync`n  const checkSupabaseSyncStatus = useCallback(async (userAddress: string) => {`n    try {`n      console.log(`Checking Supabase sync status for user: ${userAddress}`);`n`n      // Check if user is registered on-chain`n      const script = await checkUserRegistration();`n      const registrationStatus = await fcl.query({`n        cadence: script,`n        args: (arg, t) => [arg(userAddress, t.Address)],`n      });`n`n      const isFullyRegistered = registrationStatus.isFullyRegistered as boolean;`n`n      if (!isFullyRegistered) {`n        console.log("User not registered on-chain");`n        setNeedsSupabaseSync(false);`n        setShowSyncModal(false);`n        return;`n      }`n`n      // Check if user exists in Supabase`n      const { data: existingUser, error: checkError } = await supabase`n        .from("users")`n        .select("address, username, last_updated")`n        .eq("address", userAddress)`n        .single();`n`n      if (checkError && checkError.code !== 'PGRST116') { // PGRST116 = no rows returned`n        console.error("Error checking Supabase user:", checkError);`n        return;`n      }`n`n      // If user is registered on-chain but not in Supabase, they need sync`n      if (!existingUser) {`n        console.log("User registered on-chain but not found in Supabase - needs sync");`n        setNeedsSupabaseSync(true);`n        setShowSyncModal(true);`n        return;`n      }`n`n      // If user exists but data might be stale (older than 7 days), suggest resync`n      if (existingUser.last_updated) {`n        const lastUpdated = new Date(existingUser.last_updated);`n        const daysSinceUpdate = (Date.now() - lastUpdated.getTime()) / (1000 * 60 * 60 * 24);`n        `n        if (daysSinceUpdate > 7) {`n          console.log("User data is stale - suggesting resync");`n          setNeedsSupabaseSync(true);`n          // Don't show modal for stale data, just mark as needing sync`n        }`n      }`n`n      console.log("User is properly synced with Supabase");`n      setNeedsSupabaseSync(false);`n      setShowSyncModal(false);`n`n    } catch (error) {`n      console.error("Error checking Supabase sync status:", error);`n    }`n  }, []);`n`n  // Enhanced sync function with better error handling and retry logic`n  const syncUserToSupabase = useCallback(async (retryCount: number = 0) => {`n    if (!user?.addr || !user.loggedIn) {`n      console.log("No user address or not logged in, skipping Supabase sync");`n      return;`n    }`n`n    setIsSyncing(true);`n`n    try {`n      console.log(`Starting Supabase sync for user: ${user.addr} (attempt ${retryCount + 1})`);`n`n      // Check if user is registered on-chain`n      const script = await checkUserRegistration();`n      const registrationStatus = await fcl.query({`n        cadence: script,`n        args: (arg, t) => [arg(user.addr!, t.Address)],`n      });`n      `n      const isFullyRegistered = registrationStatus.isFullyRegistered as boolean;`n`n      if (!isFullyRegistered) {`n        console.log("User not fully registered on-chain, cannot sync to Supabase");`n        setNeedsSupabaseSync(false);`n        setShowSyncModal(false);`n        return;`n      }`n`n      // Fetch on-chain profile with retry logic`n      let profile = null;`n      for (let i = 0; i < 3; i++) {`n        try {`n          const profileScript = await getUserProfile();`n          profile = await fcl.query({`n            cadence: profileScript,`n            args: (arg, t) => [arg(user.addr!, t.Address)],`n          });`n          if (profile) break;`n        } catch (error) {`n          console.warn(`Profile fetch attempt ${i + 1} failed:`, error);`n          if (i < 2) await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));`n        }`n      }`n`n      if (!profile) {`n        throw new Error("Unable to fetch on-chain profile after multiple attempts");`n      }`n`n      const { username, displayName, bio, profileImageUrl } = profile;`n      const now = new Date().toISOString();`n`n      // Check if user exists in Supabase`n      const { data: existingUser, error: checkError } = await supabase`n        .from("users")`n        .select("*")`n        .eq("address", user.addr)`n        .single();`n`n      if (checkError && checkError.code !== 'PGRST116') {`n        throw new Error(`Error checking existing user: ${checkError.message}`);`n      }`n`n      // Prepare user data for Supabase`n      const userData = {`n        address: user.addr,`n        username,`n        display_name: displayName,`n        bio: bio || null,`n        profile_image_url: profileImageUrl || null,`n        last_updated: now,`n        // Set joined_at only for new users`n        ...(existingUser ? {} : { joined_at: now })`n      };`n`n      // Upsert user data to Supabase`n      const { data: upsertedUser, error: upsertError } = await supabase`n        .from("users")`n        .upsert(userData, { `n          onConflict: "address",`n          ignoreDuplicates: false `n        })`n        .select()`n        .single();`n`n      if (upsertError) {`n        throw new Error(`Error syncing user to Supabase: ${upsertError.message}`);`n      }`n`n      const action = existingUser ? "updated" : "created";`n      console.log(`User ${user.addr} ${action} in Supabase successfully`);`n      `n      // Initialize or update user_stats`n      const { data: existingStats, error: statsCheckError } = await supabase`n        .from("user_stats")`n        .select("*")`n        .eq("address", user.addr)`n        .single();`n`n      if (statsCheckError && statsCheckError.code !== 'PGRST116') {`n        console.warn("Error checking user stats:", statsCheckError);`n      }`n`n      if (!existingStats) {`n        // Create initial stats for new user`n        const { error: statsError } = await supabase`n          .from("user_stats")`n          .insert({`n            address: user.addr,`n            Credit Predict_points: 0,`n            total_staked: 0,`n            total_winnings: 0,`n            total_losses: 0,`n            total_markets_participated: 0,`n            win_streak: 0,`n            current_streak: 0,`n            longest_win_streak: 0,`n            average_bet_size: 0,`n            roi: 0,`n            last_updated: now`n          });`n`n        if (statsError) {`n          console.error("Error creating user stats:", statsError);`n        } else {`n          console.log(`User stats initialized for ${user.addr}`);`n        }`n      } else {`n        // Update last_updated for existing stats`n        const { error: statsUpdateError } = await supabase`n          .from("user_stats")`n          .update({ last_updated: now })`n          .eq("address", user.addr);`n`n        if (statsUpdateError) {`n          console.error("Error updating user stats timestamp:", statsUpdateError);`n        }`n      }`n`n      // Log activity for existing users (not new registrations)`n      if (existingUser) {`n        const { error: activityError } = await supabase`n          .from("activities")`n          .insert({`n            user_address: user.addr,`n            activity_type: "login",`n            details: {`n              timestamp: now,`n              user_agent: navigator.userAgent,`n              sync_type: "automatic"`n            },`n            created_at: now`n          });`n`n        if (activityError) {`n          console.error("Error logging login activity:", activityError);`n        }`n      }`n`n      // Success - update state`n      setNeedsSupabaseSync(false);`n      setShowSyncModal(false);`n      toast.success(`User data ${action} successfully!`);`n`n    } catch (error) {`n      console.error("Error syncing user to Supabase:", error);`n      `n      // Retry logic for transient errors`n      if (retryCount < 2) {`n        console.log(`Retrying sync in ${(retryCount + 1) * 2} seconds...`);`n        setTimeout(() => {`n          syncUserToSupabase(retryCount + 1);`n        }, (retryCount + 1) * 2000);`n        return;`n      }`n      `n      toast.error("Failed to sync user data. Please try again manually.");`n      setNeedsSupabaseSync(true);`n    } finally {`n      setIsSyncing(false);`n    }`n  }, [user?.addr, user?.loggedIn]);`n`n  // Manual sync trigger for the sync modal`n  const handleManualSync = useCallback(async () => {`n    await syncUserToSupabase(0);`n  }, [syncUserToSupabase]);`n`n  useEffect(() => {`n    flowConfig();`n`n    const checkExistingSession = async () => {`n      if (isSessionExpired()) {`n        await autoLogout();`n        return;`n      }`n    };`n`n    checkExistingSession();`n`n    const unsubscribe = fcl.currentUser.subscribe((currentUser: User) => {`n      setUser(currentUser);`n      setIsLoading(false);`n`n      if (currentUser?.loggedIn && currentUser?.addr) {`n        if (!getSessionTimestamp()) {`n          saveSessionTimestamp();`n        }`n        startSessionMonitoring();`n        startBalanceMonitoring(currentUser.addr);`n        `n        // Check Supabase sync status first, then sync if needed`n        setTimeout(async () => {`n          await checkSupabaseSyncStatus(currentUser.addr!);`n          // Only sync if the user doesn't need manual intervention`n          if (!needsSupabaseSync) {`n            await syncUserToSupabase();`n          }`n        }, 2000);`n      } else {`n        clearSessionData();`n        clearTimers();`n        stopBalanceMonitoring();`n        setSessionTimeRemaining(0);`n        setShowOnboarding(false);`n        setShowSyncModal(false);`n        setNeedsSupabaseSync(false);`n      }`n    });`n`n    return () => {`n      unsubscribe();`n      clearTimers();`n    };`n  }, [`n    isSessionExpired,`n    autoLogout,`n    getSessionTimestamp,`n    saveSessionTimestamp,`n    startSessionMonitoring,`n    startBalanceMonitoring,`n    clearSessionData,`n    clearTimers,`n    stopBalanceMonitoring,`n    syncUserToSupabase,`n    checkSupabaseSyncStatus,`n    needsSupabaseSync,`n  ]);`n`n  useEffect(() => {`n    const events = [`n      "mousedown",`n      "mousemove",`n      "keypress",`n      "scroll",`n      "touchstart",`n      "click",`n    ];`n`n    const handleActivity = () => {`n      resetSessionActivity();`n    };`n`n    events.forEach((event) => {`n      document.addEventListener(event, handleActivity, true);`n    });`n`n    return () => {`n      events.forEach((event) => {`n        document.removeEventListener(event, handleActivity, true);`n      });`n    };`n  }, [resetSessionActivity]);`n`n  useEffect(() => {`n    const checkOnboarding = async () => {`n      if (user?.addr && user.loggedIn) {`n        try {`n          const script = await checkUserRegistration();`n          const registrationStatus = await fcl.query({`n            cadence: script,`n            args: (arg, t) => [arg(user?.addr || "", t.Address)],`n          });`n          const isFullyRegistered = registrationStatus.isFullyRegistered as boolean;`n          if (!isFullyRegistered) {`n            console.log(`n              `No full registration found for address ${user.addr}. Showing onboarding modal.``n            );`n            setShowOnboarding(true);`n          } else {`n            console.log(`n              `User fully registered for address ${user.addr}. Hiding onboarding modal.``n            );`n            setShowOnboarding(false);`n          }`n        } catch (error) {`n          console.error("Failed to check user registration:", error);`n          setShowOnboarding(true);`n        }`n      } else {`n        console.log(`n          "User not logged in or address unavailable. Hiding onboarding modal."`n        );`n        setShowOnboarding(false);`n      }`n    };`n    checkOnboarding();`n  }, [user?.addr, user?.loggedIn]);`n`n  const handleCreateAccount = async () => {`n    setOnboardingError("");`n    if (!onboardingUsername.trim() || !onboardingDisplayName.trim()) {`n      setOnboardingError("Username and display name are required.");`n      toast.error("Username and display name are required.");`n      return;`n    }`n    if (!/^[a-zA-Z0-9_]+$/.test(onboardingUsername)) {`n      setOnboardingError(`n        "Username can only contain letters, numbers, and underscores."`n      );`n      toast.error(`n        "Username can only contain letters, numbers, and underscores."`n      );`n      return;`n    }`n    if (onboardingUsername.length < 1 || onboardingUsername.length > 30) {`n      setOnboardingError("Username must be 1-30 characters.");`n      toast.error("Username must be 1-30 characters.");`n      return;`n    }`n    if (onboardingDisplayName.length < 1 || onboardingDisplayName.length > 50) {`n      setOnboardingError("Display name must be 1-50 characters.");`n      toast.error("Display name must be 1-50 characters.");`n      return;`n    }`n    if (onboardingBio.length > 200) {`n      setOnboardingError("Bio must be 200 characters or less.");`n      toast.error("Bio must be 200 characters or less.");`n      return;`n    }`n    if (!user?.addr) {`n      setOnboardingError("User address is not available.");`n      toast.error("Please reconnect your wallet and try again.");`n      return;`n    }`n`n    const profileImageUrl = `https://api.dicebear.com/9.x/pixel-art/png?seed=${user.addr}&backgroundColor=ff5733,00d4ff,9b87f5&size=256&scale=80&radius=10`;`n`n    setIsCreatingAccount(true);`n    try {`n      const tx = await createUserAccountTransaction();`n      const authorization = fcl.currentUser.authorization;`n      const txId = await fcl.mutate({`n        cadence: tx,`n        args: (arg, t) => [`n          arg(onboardingUsername.trim(), t.String),`n          arg(onboardingDisplayName.trim(), t.String),`n          arg(onboardingBio.trim(), t.String),`n          arg(profileImageUrl, t.String),`n        ],`n        proposer: authorization,`n        payer: authorization,`n        authorizations: [authorization],`n        limit: 999,`n      });`n      const result = await fcl.tx(txId).onceSealed();`n      if (result.status === 4 && !result.errorMessage) {`n        let profile = null;`n        for (let i = 0; i < 5; i++) {`n          const script = await getUserProfile();`n          profile = await fcl.query({`n            cadence: script,`n            args: (arg, t) => [arg(user.addr ?? "", t.Address)],`n          });`n          if (profile) break;`n          await new Promise((res) => setTimeout(res, 1000));`n        }`n        if (profile) {`n          console.log(`Profile created successfully for address ${user.addr}.`);`n          setShowOnboarding(false);`n          setOnboardingUsername("");`n          setOnboardingDisplayName("");`n          setOnboardingBio("");`n          toast.success("User account created successfully!");`n          `n          // Log registration activity`n          const now = new Date().toISOString();`n          await supabase`n            .from("activities")`n            .insert({`n              user_address: user.addr,`n              activity_type: "registration",`n              details: {`n                username: onboardingUsername.trim(),`n                display_name: onboardingDisplayName.trim(),`n                registration_timestamp: now`n              },`n              points_earned: 100, // Welcome bonus`n              created_at: now`n            });`n`n          // Sync to Supabase after successful account creation`n          await syncUserToSupabase();`n        } else {`n          const errorMsg =`n            "Account created, but profile not yet available. Please try again.";`n          setOnboardingError(errorMsg);`n          toast.error(errorMsg);`n        }`n      } else {`n        throw new Error(result.errorMessage || "Transaction failed");`n      }`n    } catch (err: any) {`n      let errorMsg = typeof err.message === "string" ? err.message.toLowerCase() : "";`n      if (errorMsg.includes("username is already taken")) {`n        errorMsg = "Username has been taken.";`n      } else if (errorMsg.includes("already registered")) {`n        errorMsg = "User already registered.";`n      } else {`n        errorMsg = err.message || "Failed to create user account.";`n      }`n      setOnboardingError(errorMsg);`n      toast.error(`n        errorMsg === "Username has been taken."`n          ? "Username has been taken. Please choose another."`n          : errorMsg === "User already registered."`n          ? "This wallet is already registered. Please log in."`n          : errorMsg`n      );`n      setShowOnboarding(`n        errorMsg !== "Username has been taken." &&`n        errorMsg !== "User already registered."`n      );`n    } finally {`n      setIsCreatingAccount(false);`n    }`n  };`n`n  const login = async (): Promise<void> => {`n    try {`n      setIsLoading(true);`n      await fcl.authenticate();`n      saveSessionTimestamp();`n    } catch (error) {`n      console.error("Login failed:", error);`n      toast.error("Login failed. Please try again.");`n      throw error;`n    } finally {`n      setIsLoading(false);`n    }`n  };`n`n  const logout = async (): Promise<void> => {`n    try {`n      setIsLoading(true);`n      await fcl.unauthenticate();`n      setUser(null);`n      clearSessionData();`n      clearTimers();`n      stopBalanceMonitoring();`n      toast.success("Logged out successfully.");`n    } catch (error) {`n      console.error("Logout failed:", error);`n      toast.error("Logout failed. Please try again.");`n      throw error;`n    } finally {`n      setIsLoading(false);`n    }`n  };`n`n  const authenticate = async (): Promise<void> => {`n    try {`n      setIsLoading(true);`n      await fcl.authenticate();`n      saveSessionTimestamp();`n    } catch (error) {`n      console.error("Authentication failed:", error);`n      toast.error("Authentication failed. Please try again.");`n      throw error;`n    } finally {`n      setIsLoading(false);`n    }`n  };`n`n  const unauthenticate = async (): Promise<void> => {`n    try {`n      setIsLoading(true);`n      await fcl.unauthenticate();`n      clearSessionData();`n      clearTimers();`n      stopBalanceMonitoring();`n      toast.success("Unauthenticated successfully.");`n    } catch (error) {`n      console.error("Unauthentication failed:", error);`n      toast.error("Unauthentication failed. Please try again.");`n      throw error;`n    } finally {`n      setIsLoading(false);`n    }`n  };`n`n  const value: AuthContextType = {`n    user,`n    isLoading,`n    login,`n    logout,`n    authenticate,`n    unauthenticate,`n    isAuthenticated: user?.loggedIn || false,`n    walletAddress: user?.addr || null,`n    sessionTimeRemaining,`n    balance,`n    isLoadingBalance,`n    balanceError,`n    refreshBalance,`n    syncUserToSupabase: handleManualSync,`n    needsSupabaseSync,`n    isSyncing,`n  };`n`n  return (`n    <AuthContext.Provider value={value}>`n      {/* Existing Onboarding Modal */}`n      <Dialog open={showOnboarding} onOpenChange={setShowOnboarding}>`n        <DialogContent className="bg-[#0A0C14] bg-gradient-to-r from-[#0A0C14] via-[#1A1F2C] to-[#0A0C14] border border-gray-800/50">`n          <DialogHeader>`n            <DialogTitle className="text-white">Create Your Credit Predict Account</DialogTitle>`n          </DialogHeader>`n          <div className="space-y-4">`n            <div>`n              <label className="block text-gray-300 mb-1">Username</label>`n              <input`n                type="text"`n                value={onboardingUsername}`n                onChange={(e) => setOnboardingUsername(e.target.value)}`n                className="w-full p-2 rounded bg-gray-800 text-white border border-gray-700 focus:border-[#9b87f5]"`n                placeholder="Enter a username"`n                disabled={isCreatingAccount}`n              />`n            </div>`n            <div>`n              <label className="block text-gray-300 mb-1">Display Name</label>`n              <input`n                type="text"`n                value={onboardingDisplayName}`n                onChange={(e) => setOnboardingDisplayName(e.target.value)}`n                className="w-full p-2 rounded bg-gray-800 text-white border border-gray-700 focus:border-[#9b87f5]"`n                placeholder="Enter your display name"`n                disabled={isCreatingAccount}`n              />`n            </div>`n            <div>`n              <label className="block text-gray-300 mb-1">Bio</label>`n              <textarea`n                value={onboardingBio}`n                onChange={(e) => setOnboardingBio(e.target.value)}`n                className="w-full p-2 rounded bg-gray-800 text-white border border-gray-700 focus:border-[#9b87f5]"`n                placeholder="Enter a short bio (optional)"`n                disabled={isCreatingAccount}`n              />`n            </div>`n            {onboardingError && (`n              <div className="text-red-500 text-sm">{onboardingError}</div>`n            )}`n            <button`n              onClick={handleCreateAccount}`n              className="w-full bg-gradient-to-r from-[#9b87f5] to-[#8b5cf6] text-white font-bold py-2 rounded mt-2 disabled:opacity-50 flex items-center justify-center gap-2"`n              disabled={isCreatingAccount}`n            >`n              {isCreatingAccount ? (`n                <>`n                  <svg`n                    className="animate-spin h-5 w-5 text-white"`n                    xmlns="http://www.w3.org/2000/svg"`n                    fill="none"`n                    viewBox="0 0 24 24"`n                  >`n                    <circle`n                      className="opacity-25"`n                      cx="12"`n                      cy="12"`n                      r="10"`n                      stroke="currentColor"`n                      strokeWidth="4"`n                    ></circle>`n                    <path`n                      className="opacity-75"`n                      fill="currentColor"`n                      d="M4 12a8 8 0 018-8v8H4z"`n                    ></path>`n                  </svg>`n                  Creating Account...`n                </>`n              ) : (`n                "Create Account"`n              )}`n            </button>`n          </div>`n        </DialogContent>`n      </Dialog>`n`n      {/* New Supabase Sync Modal */}`n      <Dialog open={showSyncModal} onOpenChange={setShowSyncModal}>`n        <DialogContent className="bg-[#0A0C14] bg-gradient-to-r from-[#0A0C14] via-[#1A1F2C] to-[#0A0C14] border border-gray-800/50 max-w-md">`n          <DialogHeader>`n            <DialogTitle className="text-white flex items-center gap-2">`n              <Database className="h-5 w-5 text-[#9b87f5]" />`n              Sync Your Account Data`n            </DialogTitle>`n          </DialogHeader>`n          <div className="space-y-4">`n            <Alert className="border-yellow-500/20 bg-yellow-500/10">`n              <AlertTriangle className="h-4 w-4 text-yellow-500" />`n              <AlertDescription className="text-yellow-100">`n                Your account is registered on-chain but needs to be synced with our database to access all features.`n              </AlertDescription>`n            </Alert>`n            `n            <div className="text-gray-300 space-y-2">`n              <p className="text-sm">`n                We&rsquo;ve detected that your Credit Predict account exists on the blockchain but hasn&#39;t been synced with our database yet.`n              </p>`n              <p className="text-sm">`n                This sync will enable:`n              </p>`n              <ul className="text-xs text-gray-400 ml-4 space-y-1">`n                <li>â€¢ Credit Predict Points & Leaderboard</li>`n                <li>â€¢ Activity History</li>`n                <li>â€¢ Enhanced Dashboard Features</li>`n                <li>â€¢ Social Features</li>`n              </ul>`n            </div>`n`n            <div className="flex gap-3">`n              <Button`n                variant="outline"`n                onClick={() => setShowSyncModal(false)}`n                className="flex-1 border-gray-700 text-gray-300 hover:bg-[#1A1F2C] bg-transparent"`n                disabled={isSyncing}`n              >`n                Skip for Now`n              </Button>`n              <Button`n                onClick={handleManualSync}`n                disabled={isSyncing}`n                className="flex-1 bg-gradient-to-r from-[#9b87f5] to-[#8b5cf6] text-white font-medium"`n              >`n                {isSyncing ? (`n                  <>`n                    <Loader2 className="h-4 w-4 mr-2 animate-spin" />`n                    Syncing...`n                  </>`n                ) : (`n                  <>`n                    <Sync className="h-4 w-4 mr-2" />`n                    Sync Now`n                  </>`n                )}`n              </Button>`n            </div>`n`n            {isSyncing && (`n              <div className="text-center text-sm text-gray-400">`n                <div className="flex items-center justify-center gap-2">`n                  <Loader2 className="h-4 w-4 animate-spin" />`n                  Syncing your account data...`n                </div>`n              </div>`n            )}`n          </div>`n        </DialogContent>`n      </Dialog>`n`n      <div`n        style={{`n          pointerEvents: showOnboarding || showSyncModal ? "none" : undefined,`n          opacity: showOnboarding || showSyncModal ? 0.5 : 1,`n        }}`n      >`n        {children}`n      </div>`n    </AuthContext.Provider>`n  );`n};`n`nexport const useAuth = (): AuthContextType => {`n  const context = useContext(AuthContext);`n  if (context === undefined) {`n    throw new Error("useAuth must be used within an AuthProvider");`n  }`n  return context;`n};`n`n// ... (keep your existing withAuth function) ...