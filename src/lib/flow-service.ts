/* eslint-disable @typescript-eslint/no-explicit-any */`n// lib/flow-service.ts`nimport * as fcl from "@onflow/fcl";`nimport flowConfig from "@/lib/flow/config";`nimport {`n    getPendingMarketsScript,`n    getMarketByIdScript,`n    checkAdminPrivilegesScript,`n    resolveMarketTransaction`n} from "./flow/resolve-market";`n`n// Import your existing types`nimport type { `n  Market, `n  MarketOutcome, `n  Address `n} from "@/types/market";`n`n// Flow-specific interfaces`ninterface TransactionResult {`n    success: boolean;`n    transactionId: string;`n    result?: any;`n}`n`ninterface ResolutionOptions {`n    evidence: string;`n    sourceUrl: string;`n    adminNotes: string;`n}`n`n// Initialize Flow config`nconst initConfig = async () => {`n  flowConfig();`n};`n`n// =====================================`n// EXPORTED FLOW FUNCTIONS`n// =====================================`n`n// Get all markets pending resolution`nexport const getPendingMarkets = async (): Promise<Market[]> => {`n    try {`n        await initConfig();`n        `n        const script = getPendingMarketsScript();`n        const result = await fcl.query({`n            cadence: script.cadence,`n            args: () => script.args`n        });`n        `n        return result || [];`n    } catch (error) {`n        console.error("Error fetching pending markets:", error);`n        throw new Error("Failed to fetch pending markets");`n    }`n};`n`n// Get a specific market by ID`nexport const getMarket = async (marketId: string | number): Promise<Market | null> => {`n    try {`n        await initConfig();`n        `n        const script = getMarketByIdScript(marketId);`n        const result = await fcl.query({`n            cadence: script.cadence,`n            args: () => script.args`n        });`n        `n        return result;`n    } catch (error) {`n        console.error(`Error fetching market ${marketId}:`, error);`n        throw new Error(`Failed to fetch market ${marketId}`);`n    }`n};`n`n// Check if current user has admin privileges`nexport const checkAdminPrivileges = async (userAddress: Address): Promise<boolean> => {`n    try {`n        if (!userAddress) return false;`n        `n        await initConfig();`n        `n        const script = checkAdminPrivilegesScript(userAddress);`n        const result = await fcl.query({`n            cadence: script.cadence,`n            args: () => script.args`n        });`n        `n        return result === true;`n    } catch (error) {`n        console.error("Error checking admin privileges:", error);`n        return false;`n    }`n};`n`n// Resolve a market`nexport const resolveMarket = async (`n    marketId: number, `n    outcome: MarketOutcome, `n    options: ResolutionOptions = { evidence: "", sourceUrl: "", adminNotes: "" }`n): Promise<TransactionResult> => {`n    try {`n        await initConfig();`n        `n        const { evidence, sourceUrl, adminNotes } = options;`n        `n        // Get the transaction`n        const transaction = resolveMarketTransaction(marketId, outcome);`n        `n        // Execute the transaction`n        const transactionId = await fcl.mutate({`n            cadence: transaction.cadence,`n            args: () => transaction.args,`n            payer: fcl.authz,`n            proposer: fcl.authz,`n            authorizations: [fcl.authz],`n            limit: transaction.limit`n        });`n`n        console.log("Transaction submitted:", transactionId);`n`n        // Wait for transaction to be sealed`n        const result = await fcl.tx(transactionId).onceSealed();`n        `n        console.log("Transaction sealed:", result);`n`n        // Log resolution details for audit trail`n        console.log("Market Resolution Details:", {`n            marketId,`n            outcome,`n            evidence,`n            sourceUrl,`n            adminNotes,`n            transactionId,`n            timestamp: new Date().toISOString()`n        });`n`n        return {`n            success: true,`n            transactionId,`n            result`n        };`n`n    } catch (error) {`n        console.error("Error resolving market:", error);`n        const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";`n        throw new Error(`Failed to resolve market: ${errorMessage}`);`n    }`n};`n`n// =====================================`n// REACT HOOKS FOR FLOW INTEGRATION`n// =====================================`n`nimport { useState, useEffect } from 'react';`n`ninterface UsePendingMarketsReturn {`n    markets: Market[];`n    loading: boolean;`n    error: string | null;`n    refetch: () => Promise<void>;`n}`n`ninterface UseMarketResolutionReturn {`n    resolveMarket: (marketId: number, outcome: MarketOutcome, options?: ResolutionOptions) => Promise<TransactionResult>;`n    resolving: boolean;`n    error: string | null;`n}`n`n// Hook for managing pending markets`nexport function usePendingMarkets(): UsePendingMarketsReturn {`n    const [markets, setMarkets] = useState<Market[]>([]);`n    const [loading, setLoading] = useState<boolean>(true);`n    const [error, setError] = useState<string | null>(null);`n`n    const fetchMarkets = async (): Promise<void> => {`n        try {`n            setLoading(true);`n            setError(null);`n            const pendingMarkets = await getPendingMarkets();`n            setMarkets(pendingMarkets);`n        } catch (err) {`n            const errorMessage = err instanceof Error ? err.message : "Unknown error occurred";`n            setError(errorMessage);`n            console.error("Failed to fetch pending markets:", err);`n        } finally {`n            setLoading(false);`n        }`n    };`n`n    useEffect(() => {`n        fetchMarkets();`n    }, []);`n`n    return {`n        markets,`n        loading,`n        error,`n        refetch: fetchMarkets`n    };`n}`n`n// Hook for market resolution`nexport function useMarketResolution(): UseMarketResolutionReturn {`n    const [resolving, setResolving] = useState<boolean>(false);`n    const [error, setError] = useState<string | null>(null);`n`n    const resolveMarketHook = async (`n        marketId: number, `n        outcome: MarketOutcome, `n        options: ResolutionOptions = { evidence: "", sourceUrl: "", adminNotes: "" }`n    ): Promise<TransactionResult> => {`n        try {`n            setResolving(true);`n            setError(null);`n            `n            const result = await resolveMarket(marketId, outcome, options);`n            `n            return result;`n        } catch (err) {`n            const errorMessage = err instanceof Error ? err.message : "Unknown error occurred";`n            setError(errorMessage);`n            throw err;`n        } finally {`n            setResolving(false);`n        }`n    };`n`n    return {`n        resolveMarket: resolveMarketHook,`n        resolving,`n        error`n    };`n}`n`n// Export types for use in other components`nexport type { TransactionResult, ResolutionOptions };