export const getCredit PredictAddress = () => {`n  const network = process.env.NEXT_PUBLIC_FLOW_NETWORK || "testnet";`n  return network === "mainnet"`n    ? process.env.NEXT_PUBLIC_Credit Predict_CONTRACT || "0x512a5459cb3a2b20"`n    : process.env.NEXT_PUBLIC_Credit Predict_TESTNET_CONTRACT ||`n        "0x512a5459cb3a2b20";`n};`n`nexport const getFlowTokenAddress = () => {`n  const network = process.env.NEXT_PUBLIC_FLOW_NETWORK || "testnet";`n  return network === "mainnet"`n    ? process.env.NEXT_PUBLIC_FLOW_MAINNET_TOKEN || "0x1654653399040a61"`n    : process.env.NEXT_PUBLIC_FLOW_TESTNET_TOKEN || "0x7e60df042a9c0868";`n};`n`nexport const getFungibleTokenAddress = () => {`n  const network = process.env.NEXT_PUBLIC_FLOW_NETWORK || "testnet";`n  return network === "mainnet"`n    ? process.env.NEXT_PUBLIC_FLOW_FUNGIBLE_MAINNET_TOKEN ||`n        "0xf233dcee88fe0abe"`n    : process.env.NEXT_PUBLIC_FLOW_FUNGIBLE_TESTNET_TOKEN ||`n        "0x9a0766d93b6608b7";`n};`n`nconst CADENCE_SCRIPTS = {`n  getAllPendingMarkets: ``n    import Credit Predict from ${getCredit PredictAddress()}`n     access(all) struct PendingMarketDetails {`n    access(all) let market: Credit Predict.Market`n    access(all) let evidence: Credit Predict.ResolutionEvidence?`n    access(all) let totalVolume: UFix64`n    access(all) let participantCount: UInt64`n    access(all) let daysSinceEnded: UFix64`n    access(all) let hasEvidence: Bool`n    `n    init(`n        market: Credit Predict.Market,`n        evidence: Credit Predict.ResolutionEvidence?,`n        totalVolume: UFix64,`n        participantCount: UInt64,`n        daysSinceEnded: UFix64,`n        hasEvidence: Bool`n    ) {`n        self.market = market`n        self.evidence = evidence`n        self.totalVolume = totalVolume`n        self.participantCount = participantCount`n        self.daysSinceEnded = daysSinceEnded`n        self.hasEvidence = hasEvidence`n    }`n}`n        access(all) fun main(creatorAddress: Address): [PendingMarketDetails] {`n    let creatorMarkets = Credit Predict.getMarketsByCreator(creator: creatorAddress)`n    let pendingMarkets: [PendingMarketDetails] = []`n    let currentTime = getCurrentBlock().timestamp`n    `n    for market in creatorMarkets {`n        // Check if market is in pending resolution status`n        if market.status == Credit Predict.MarketStatus.PendingResolution {`n            // Get evidence if it exists`n            let evidence = Credit Predict.getResolutionEvidence(marketId: market.id)`n            `n            // Calculate total volume`n            let totalVolume = market.totalOptionAShares + market.totalOptionBShares`n            `n            // Calculate days since market ended`n            let secondsSinceEnded = currentTime >= market.endTime ? currentTime - market.endTime : 0.0`n            let daysSinceEnded = secondsSinceEnded / 86400.0 // Convert seconds to days`n            `n            // Get actual participant count from contract's marketParticipants mapping`n            let participantCount = Credit Predict.getMarketParticipantCount(marketId: market.id)`n            `n            pendingMarkets.append(PendingMarketDetails(`n                market: market,`n                evidence: evidence,`n                totalVolume: totalVolume,`n                participantCount: participantCount,`n                daysSinceEnded: daysSinceEnded,`n                hasEvidence: evidence != nil`n            ))`n        }`n    }`n    `n    return pendingMarkets`n}`n    `,`n  getUserTrades: ``n    import Credit Predict from ${getCredit PredictAddress()}`n    import FlowToken from ${getFlowTokenAddress()}`nimport FungibleToken from  ${getFungibleTokenAddress()}`n`naccess(all) struct TradeDetails {`n    access(all) let marketId: UInt64`n    access(all) let marketTitle: String`n    access(all) let marketDescription: String`n    access(all) let optionA: String`n    access(all) let optionB: String`n    access(all) let optionAShares: UFix64`n    access(all) let optionBShares: UFix64`n    access(all) let totalInvested: UFix64`n    access(all) let averagePrice: UFix64`n    access(all) let endTime: UFix64`n    access(all) let currentValue: UFix64`n    access(all) let profitLoss: Fix64`n`n    init(`n        marketId: UInt64,`n        marketTitle: String,`n        marketDescription: String,`n        optionA: String,`n        optionB: String,`n        optionAShares: UFix64,`n        optionBShares: UFix64,`n        totalInvested: UFix64,`n        averagePrice: UFix64,`n        endTime: UFix64,`n        currentValue: UFix64,`n        profitLoss: Fix64`n    ) {`n        self.marketId = marketId`n        self.marketTitle = marketTitle`n        self.marketDescription = marketDescription`n        self.optionA = optionA`n        self.optionB = optionB`n        self.optionAShares = optionAShares`n        self.optionBShares = optionBShares`n        self.totalInvested = totalInvested`n        self.averagePrice = averagePrice`n        self.endTime = endTime`n        self.currentValue = currentValue`n        self.profitLoss = profitLoss`n    }`n}`n`naccess(all) struct UserTrades {`n    access(all) let activeTrades: [TradeDetails]`n    access(all) let totalDeposited: UFix64`n`n    init(activeTrades: [TradeDetails], totalDeposited: UFix64) {`n        self.activeTrades = activeTrades`n        self.totalDeposited = totalDeposited`n    }`n}`n`naccess(all) fun calculateCurrentValue(`n    position: Credit Predict.UserPosition,`n    market: Credit Predict.Market`n): UFix64 {`n    let totalShares = position.optionAShares + position.optionBShares`n    if totalShares == 0.0 {`n        return 0.0`n    }`n    `n    let totalMarketShares = market.totalOptionAShares + market.totalOptionBShares`n    if totalMarketShares == 0.0 {`n        return position.totalInvested`n    }`n    `n    let shareRatio = totalShares / totalMarketShares`n    let distributablePool = market.totalPool * (1.0 - (Credit Predict.platformFeePercentage / 100.0))`n    `n    return distributablePool * shareRatio`n}`n`naccess(all) fun main(userAddress: Address): UserTrades {`n    let positionsDict = Credit Predict.getUserPositions(address: userAddress)`n    var activeTrades: [TradeDetails] = []`n    var totalDeposited: UFix64 = 0.0`n    `n    for marketId in positionsDict.keys {`n        if let market = Credit Predict.getMarketById(marketId: marketId) {`n            if market.status == Credit Predict.MarketStatus.Active {`n                let position = positionsDict[marketId]!`n                `n                let currentValue = calculateCurrentValue(position: position, market: market)`n                let profitLoss = Fix64(currentValue) - Fix64(position.totalInvested)`n                `n                activeTrades.append(TradeDetails(`n                    marketId: marketId,`n                    marketTitle: market.title,`n                    marketDescription: market.description,`n                    optionA: market.optionA,`n                    optionB: market.optionB,`n                    optionAShares: position.optionAShares,`n                    optionBShares: position.optionBShares,`n                    totalInvested: position.totalInvested,`n                    averagePrice: position.averagePrice,`n                    endTime: market.endTime,`n                    currentValue: currentValue,`n                    profitLoss: profitLoss`n                ))`n            }`n            // Sum totalInvested for all positions (active or not)`n            totalDeposited = totalDeposited + positionsDict[marketId]!.totalInvested`n        }`n    }`n    `n    return UserTrades(activeTrades: activeTrades, totalDeposited: totalDeposited)`n}`n  `,`n`n  getActiveUserPositions: ``n    import Credit Predict from ${getCredit PredictAddress()}`n    import FlowToken from ${getFlowTokenAddress()}`n    import FungibleToken from ${getFungibleTokenAddress()}`n`n    access(all) struct PositionDetails {`n        access(all) let marketId: UInt64`n        access(all) let marketTitle: String`n        access(all) let optionAShares: UFix64`n        access(all) let optionBShares: UFix64`n        access(all) let totalInvested: UFix64`n        access(all) let currentValue: UFix64`n        access(all) let pnl: Fix64`n        access(all) let pnlPercentage: Fix64`n        access(all) let status: Credit Predict.MarketStatus`n        access(all) let outcome: UInt8?`n`n        init(`n            marketId: UInt64,`n            marketTitle: String,`n            optionAShares: UFix64,`n            optionBShares: UFix64,`n            totalInvested: UFix64,`n            currentValue: UFix64,`n            pnl: Fix64,`n            pnlPercentage: Fix64,`n            status: Credit Predict.MarketStatus,`n            outcome: UInt8?`n        ) {`n            self.marketId = marketId`n            self.marketTitle = marketTitle`n            self.optionAShares = optionAShares`n            self.optionBShares = optionBShares`n            self.totalInvested = totalInvested`n            self.currentValue = currentValue`n            self.pnl = pnl`n            self.pnlPercentage = pnlPercentage`n            self.status = status`n            self.outcome = outcome`n        }`n    }`n`n    access(all) fun calculateCurrentValue(`n        position: Credit Predict.UserPosition,`n        market: Credit Predict.Market,`n        claimableWinnings: {UInt64: UFix64}`n    ): UFix64 {`n        let totalShares = position.optionAShares + position.optionBShares`n        if totalShares == 0.0 {`n            return 0.0`n        }`n        `n        if market.resolved {`n            return claimableWinnings[market.id] ?? 0.0`n        }`n        `n        let totalMarketShares = market.totalOptionAShares + market.totalOptionBShares`n        if totalMarketShares == 0.0 {`n            return position.totalInvested`n        }`n        `n        let shareRatio = totalShares / totalMarketShares`n        let distributablePool = market.totalPool * (1.0 - (Credit Predict.platformFeePercentage / 100.0))`n        `n        return distributablePool * shareRatio`n    }`n`n    access(all) fun main(userAddress: Address): [PositionDetails] {`n        let positionsDict = Credit Predict.getUserPositions(address: userAddress)`n        let claimableWinningsRaw = Credit Predict.getClaimableWinnings(address: userAddress)`n        let claimableWinnings: {UInt64: UFix64} = {}`n        for cw in claimableWinningsRaw {`n            claimableWinnings[cw.marketId] = cw.amount`n        }`n        `n        var positionDetails: [PositionDetails] = []`n        `n        for marketId in positionsDict.keys {`n            if let market = Credit Predict.getMarketById(marketId: marketId) {`n                let position = positionsDict[marketId]!`n                let currentValue = calculateCurrentValue(`n                    position: position,`n                    market: market,`n                    claimableWinnings: claimableWinnings`n                )`n                let pnl = Fix64(currentValue) - Fix64(position.totalInvested)`n                let pnlPercentage = position.totalInvested > 0.0 `n                    ? (pnl / Fix64(position.totalInvested)) * 100.0 `n                    : 0.0`n                `n                positionDetails.append(PositionDetails(`n                    marketId: marketId,`n                    marketTitle: market.title,`n                    optionAShares: position.optionAShares,`n                    optionBShares: position.optionBShares,`n                    totalInvested: position.totalInvested,`n                    currentValue: currentValue,`n                    pnl: pnl,`n                    pnlPercentage: pnlPercentage,`n                    status: market.status,`n                    outcome: market.outcome`n                ))`n            }`n        }`n        `n        return positionDetails`n    }`n  `,`n`n  getActiveMarkets: ``n    import Credit Predict from ${getCredit PredictAddress()}`n`n    access(all) fun main(): [Credit Predict.Market] {`n        return Credit Predict.getActiveMarkets()`n    }`n  `,`n`n  getAllMarkets: ``n    import Credit Predict from ${getCredit PredictAddress()}`n`n    access(all) fun main(): [Credit Predict.Market] {`n        return Credit Predict.getAllMarkets()`n    }`n  `,`n`n  getMarketById: ``n    import Credit Predict from ${getCredit PredictAddress()}`n`n    access(all) fun main(marketId: UInt64): Credit Predict.Market? {`n        return Credit Predict.getMarketById(marketId: marketId)`n    }`n  `,`n`n  getMarketByCreator: ``n    import Credit Predict from ${getCredit PredictAddress()}`n`n    access(all) fun main(creator: Address): [Credit Predict.Market] {`n      return Credit Predict.getMarketsByCreator(creator: creator)`n    }`n  `,`n`n  getPlatformStats: ``n    import Credit Predict from ${getCredit PredictAddress()}`n`n    access(all) fun main(): Credit Predict.PlatformStats {`n        return Credit Predict.getPlatformStats()`n    }`n  `,`n`n  getUserFlowBalance: ``n    import FlowToken from ${getFlowTokenAddress()}`n    import FungibleToken from ${getFungibleTokenAddress()}`n`n    access(all) fun main(address: Address): UFix64 {`n        let account = getAccount(address)`n        let vaultRef = account.capabilities.get<&FlowToken.Vault>(/public/flowTokenBalance)`n            .borrow()`n            ?? panic("Could not borrow Vault reference")`n        return vaultRef.balance`n    }`n  `,`n`n  getUserProfile: ``n    import Credit Predict from ${getCredit PredictAddress()}`n`naccess(all) fun main(address: Address): &{Credit Predict.UserProfilePublic}? {`n    return Credit Predict.getUserProfile(address: address)`n}`n  `,`n`n  getPendingMarkets: ``n    import Credit Predict from ${getCredit PredictAddress()}`n`n    access(all) fun main(): [Credit Predict.Market] {`n        return Credit Predict.getPendingResolutionMarkets()`n    }`n  `,`n`n  getPendingMarketsWithEvidence: ``n  import Credit Predict from ${getCredit PredictAddress()}`n`n  access(all) fun main(creatorAddress: Address): [Credit Predict.Market] {`n      let creatorMarkets = Credit Predict.getMarketsByCreator(creator: creatorAddress)`n      let pendingWithEvidence: [Credit Predict.Market] = []`n      `n      for market in creatorMarkets {`n          if market.status == Credit Predict.MarketStatus.PendingResolution {`n              if Credit Predict.getResolutionEvidence(marketId: market.id) != nil {`n                  pendingWithEvidence.append(market)`n              }`n          }`n      }`n      `n      return pendingWithEvidence`n  }`n`,`n`n  getUserPositions: ``n  import Credit Predict from ${getCredit PredictAddress()}`n  import FlowToken from ${getFlowTokenAddress()}`n  import FungibleToken from ${getFungibleTokenAddress()}`n`n  access(all) struct PositionDetails {`n      access(all) let marketId: UInt64`n      access(all) let marketTitle: String`n      access(all) let marketDescription: String`n      access(all) let optionA: String`n      access(all) let optionB: String`n      access(all) let optionAShares: UFix64`n      access(all) let optionBShares: UFix64`n      access(all) let totalInvested: UFix64`n      access(all) let averagePrice: UFix64`n      access(all) let endTime: UFix64`n      access(all) let status: Credit Predict.MarketStatus`n      access(all) let currentValue: UFix64`n      access(all) let profitLoss: Fix64`n      access(all) let claimableAmount: UFix64`n      access(all) let claimed: Bool`n`n      init(`n          marketId: UInt64,`n          marketTitle: String,`n          marketDescription: String,`n          optionA: String,`n          optionB: String,`n          optionAShares: UFix64,`n          optionBShares: UFix64,`n          totalInvested: UFix64,`n          averagePrice: UFix64,`n          endTime: UFix64,`n          status: Credit Predict.MarketStatus,`n          currentValue: UFix64,`n          profitLoss: Fix64,`n          claimableAmount: UFix64,`n          claimed: Bool`n      ) {`n          self.marketId = marketId`n          self.marketTitle = marketTitle`n          self.marketDescription = marketDescription`n          self.optionA = optionA`n          self.optionB = optionB`n          self.optionAShares = optionAShares`n          self.optionBShares = optionBShares`n          self.totalInvested = totalInvested`n          self.averagePrice = averagePrice`n          self.endTime = endTime`n          self.status = status`n          self.currentValue = currentValue`n          self.profitLoss = profitLoss`n          self.claimableAmount = claimableAmount`n          self.claimed = claimed`n      }`n  }`n`n  access(all) fun calculateCurrentValue(`n      position: Credit Predict.UserPosition,`n      market: Credit Predict.Market,`n      claimableWinnings: {UInt64: UFix64}`n  ): UFix64 {`n      let totalShares = position.optionAShares + position.optionBShares`n      if totalShares == 0.0 {`n          return 0.0`n      }`n      `n      if market.resolved {`n          return claimableWinnings[market.id] ?? 0.0`n      }`n      `n      let totalMarketShares = market.totalOptionAShares + market.totalOptionBShares`n      if totalMarketShares == 0.0 {`n          return position.totalInvested`n      }`n      `n      let shareRatio = totalShares / totalMarketShares`n      let distributablePool = market.totalPool * (1.0 - (Credit Predict.platformFeePercentage / 100.0))`n      `n      return distributablePool * shareRatio`n  }`n`n  access(all) fun main(userAddress: Address): [PositionDetails] {`n      let positionsDict = Credit Predict.getUserPositions(address: userAddress)`n      let claimableWinningsRaw = Credit Predict.getClaimableWinnings(address: userAddress)`n      let claimableWinnings: {UInt64: UFix64} = {}`n      for cw in claimableWinningsRaw {`n          claimableWinnings[cw.marketId] = cw.amount`n      }`n      `n      var positionDetails: [PositionDetails] = []`n      `n      for marketId in positionsDict.keys {`n          if let market = Credit Predict.getMarketById(marketId: marketId) {`n              let position = positionsDict[marketId]!`n              `n              let currentValue = calculateCurrentValue(`n                  position: position,`n                  market: market,`n                  claimableWinnings: claimableWinnings`n              )`n              let profitLoss = Fix64(currentValue) - Fix64(position.totalInvested)`n              let claimableAmount = market.resolved && !position.claimed`n                  ? claimableWinnings[marketId] ?? 0.0`n                  : 0.0`n              `n              positionDetails.append(PositionDetails(`n                  marketId: marketId,`n                  marketTitle: market.title,`n                  marketDescription: market.description,`n                  optionA: market.optionA,`n                  optionB: market.optionB,`n                  optionAShares: position.optionAShares,`n                  optionBShares: position.optionBShares,`n                  totalInvested: position.totalInvested,`n                  averagePrice: position.averagePrice,`n                  endTime: market.endTime,`n                  status: market.status,`n                  currentValue: currentValue,`n                  profitLoss: profitLoss,`n                  claimableAmount: claimableAmount,`n                  claimed: position.claimed`n              ))`n          }`n      }`n      `n      return positionDetails`n  }`n`,`n`n  getUserDashboardData: ``n    import Credit Predict from ${getCredit PredictAddress()}`n`naccess(all) struct UserDashboard {`n    access(all) let profile: &{Credit Predict.UserProfilePublic}?`n    access(all) let stats: Credit Predict.UserStats?`n    access(all) let positions: {UInt64: Credit Predict.UserPosition}`n    access(all) let claimableWinnings: [Credit Predict.ClaimableWinnings]`n    access(all) let isRegistered: Bool`n    access(all) let totalMarketsCreated: UInt64`n    access(all) let createdMarkets: [Credit Predict.Market]`n    `n    init(`n        profile: &{Credit Predict.UserProfilePublic}?,`n        stats: Credit Predict.UserStats?,`n        positions: {UInt64: Credit Predict.UserPosition},`n        claimableWinnings: [Credit Predict.ClaimableWinnings],`n        isRegistered: Bool,`n        totalMarketsCreated: UInt64,`n        createdMarkets: [Credit Predict.Market]`n    ) {`n        self.profile = profile`n        self.stats = stats`n        self.positions = positions`n        self.claimableWinnings = claimableWinnings`n        self.isRegistered = isRegistered`n        self.totalMarketsCreated = totalMarketsCreated`n        self.createdMarkets = createdMarkets`n    }`n}`n`naccess(all) fun main(userAddress: Address): UserDashboard {`n    // Get user profile (returns a reference, not the resource itself)`n    let profile = Credit Predict.getUserProfile(address: userAddress)`n    `n    // Get user stats`n    let stats = Credit Predict.getUserStats(address: userAddress)`n    `n    // Get user positions (with error handling for unregistered users)`n    var positions: {UInt64: Credit Predict.UserPosition} = {}`n    if stats != nil {`n        positions = Credit Predict.getUserPositions(address: userAddress)`n    }`n    `n    // Get claimable winnings`n    let claimableWinnings = Credit Predict.getClaimableWinnings(address: userAddress)`n    `n    // Check if user is registered`n    let isRegistered = stats != nil && profile != nil`n    `n    // Get markets created by this user`n    let createdMarkets = Credit Predict.getMarketsByCreator(creator: userAddress)`n    let totalMarketsCreated = UInt64(createdMarkets.length)`n    `n    return UserDashboard(`n        profile: profile,`n        stats: stats,`n        positions: positions,`n        claimableWinnings: claimableWinnings,`n        isRegistered: isRegistered,`n        totalMarketsCreated: totalMarketsCreated,`n        createdMarkets: createdMarkets`n    )`n}`n  `,`n`n  activeUserPositions: ``n    import Credit Predict from ${getCredit PredictAddress()}`n`n    access(all) struct ActivePosition {`n        access(all) let marketId: UInt64`n        access(all) let marketTitle: String`n        access(all) let optionAShares: UFix64`n        access(all) let optionBShares: UFix64`n        access(all) let totalInvested: UFix64`n`n        init(`n            marketId: UInt64,`n            marketTitle: String,`n            optionAShares: UFix64,`n            optionBShares: UFix64,`n            totalInvested: UFix64`n        ) {`n            self.marketId = marketId`n            self.marketTitle = marketTitle`n            self.optionAShares = optionAShares`n            self.optionBShares = optionBShares`n            self.totalInvested = totalInvested`n        }`n    }`n`n    access(all) fun main(userAddress: Address): [ActivePosition] {`n        let positionsDict = Credit Predict.getUserPositions(address: userAddress)`n        var activePositions: [ActivePosition] = []`n        for marketId in positionsDict.keys {`n            if let market = Credit Predict.getMarketById(marketId: marketId) {`n                if market.status == Credit Predict.MarketStatus.Active {`n                    let position = positionsDict[marketId]!`n                    activePositions.append(ActivePosition(`n                        marketId: marketId,`n                        marketTitle: market.title,`n                        optionAShares: position.optionAShares,`n                        optionBShares: position.optionBShares,`n                        totalInvested: position.totalInvested`n                    ))`n                }`n            }`n        }`n        return activePositions`n    }`n  `,`n`n  getClaimableWinnings: ``n    import Credit Predict from ${getCredit PredictAddress()}`n`n    access(all) fun main(address: Address): [Credit Predict.ClaimableWinnings] {`n        return Credit Predict.getClaimableWinnings(address: address)`n    }`n  `,`n`n  createUserAccount: ``n    import Credit Predict from ${getCredit PredictAddress()}`n    import FlowToken from ${getFlowTokenAddress()}`n`n  transaction(username: String, displayName: String, bio: String, profileImageUrl: String) {`n    prepare(signer: auth(BorrowValue, SaveValue, PublishCapability, StorageCapabilities ) &Account) {`n        // Create user account in contract`n        Credit Predict.createUserAccount(`n            userAddress: signer.address,`n            username: username,`n            displayName: displayName`n        )`n        `n        // Create and save UserProfile resource`n        let userProfile <- Credit Predict.createUserProfile(`n            userAddress: signer.address,`n            username: username,`n            displayName: displayName,`n            bio: bio,`n            profileImageUrl: profileImageUrl`n        )`n        signer.storage.save(<-userProfile, to: Credit Predict.UserProfileStoragePath)`n        `n        // Create UserProfile capability`n        let userProfileCap = signer.capabilities.storage.issue<&{Credit Predict.UserProfilePublic}>(`n            Credit Predict.UserProfileStoragePath`n        )`n        signer.capabilities.publish(userProfileCap, at: Credit Predict.UserProfilePublicPath)`n        `n        // Create and save UserPositions resource`n        let userPositions <- Credit Predict.createUserPositions()`n        signer.storage.save(<-userPositions, to: Credit Predict.UserPositionsStoragePath)`n        `n        // Create UserPositions capability`n        let userPositionsCap = signer.capabilities.storage.issue<&{Credit Predict.UserPositionsPublic}>(`n            Credit Predict.UserPositionsStoragePath`n        )`n        signer.capabilities.publish(userPositionsCap, at: Credit Predict.UserPositionsPublicPath)`n        `n        // Create and save UserStats resource`n        let userStats <- Credit Predict.createUserStatsResource()`n        signer.storage.save(<-userStats, to: Credit Predict.UserStatsStoragePath)`n        `n        // Create UserStats capability`n        let userStatsCap = signer.capabilities.storage.issue<&{Credit Predict.UserStatsPublic}>(`n            Credit Predict.UserStatsStoragePath`n        )`n        signer.capabilities.publish(userStatsCap, at: Credit Predict.UserStatsPublicPath)`n        `n        log("User account setup completed for: ".concat(username))`n    }`n}`n  `,`n`n  createMarket: ``n    import Credit Predict from ${getCredit PredictAddress()}`n    import FlowToken from ${getFlowTokenAddress()}`n    import FungibleToken from ${getFungibleTokenAddress()}`n`n   transaction(`n    title: String,`n    description: String,`n    categoryRaw: UInt8,`n    optionA: String,`n    optionB: String,`n    endTime: UFix64,`n    minBet: UFix64,`n    maxBet: UFix64,`n    imageUrl: String`n) {`n    let flowVault: @FlowToken.Vault?`n    let category: Credit Predict.MarketCategory`n    let signerAddress: Address`n    let isDeployer: Bool`n    `n    prepare(signer: auth(BorrowValue) &Account) {`n        // Store the category and signer address for use in execute`n        self.category = Credit Predict.MarketCategory(rawValue: categoryRaw)!`n        self.signerAddress = signer.address`n        `n        // Check if signer is the deployer (gets contract deployer address)`n        let deployerAddress = Credit Predict.deployerAddress`n        self.isDeployer = signer.address == deployerAddress`n        `n        // Only prepare creation fee if user is NOT the deployer`n        if !self.isDeployer {`n            let vault = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(`n                from: /storage/flowTokenVault`n            ) ?? panic("Could not borrow FlowToken vault")`n            `n            // Get the current market creation fee from contract`n            let marketCreationFee = Credit Predict.marketCreationFee`n            self.flowVault <- vault.withdraw(amount: marketCreationFee) as! @FlowToken.Vault`n            `n            log("Creation fee of ".concat(marketCreationFee.toString()).concat(" FLOW will be charged"))`n        } else {`n            self.flowVault <- nil`n            log("No creation fee required for deployer")`n        }`n    }`n    `n    execute {`n        let marketId = Credit Predict.createMarket(`n            title: title,`n            description: description,`n            category: self.category,`n            optionA: optionA,`n            optionB: optionB,`n            endTime: endTime,`n            minBet: minBet,`n            maxBet: maxBet,`n            imageUrl: imageUrl,`n            creationFeeVault: <-self.flowVault,`n            address: self.signerAddress`n        )`n        `n        log("Market created with ID: ".concat(marketId.toString()))`n    }`n}`n  `,`n`n  checkUserRegistered: ``n  import Credit Predict from ${getCredit PredictAddress()}`n`naccess(all) fun main(userAddress: Address): {String: AnyStruct} {`n    // Check if user is registered in the contract`n    let userStats = Credit Predict.getUserStats(address: userAddress)`n    let isRegisteredInContract = userStats != nil`n    `n    // Check if user has UserProfile resource`n    let account = getAccount(userAddress)`n    let userProfile = account.capabilities.get<&{Credit Predict.UserProfilePublic}>(`n        Credit Predict.UserProfilePublicPath`n    ).borrow()`n    let hasUserProfile = userProfile != nil`n    `n    // Check if user has UserPositions resource`n    let userPositions = account.capabilities.get<&{Credit Predict.UserPositionsPublic}>(`n        Credit Predict.UserPositionsPublicPath`n    ).borrow()`n    let hasUserPositions = userPositions != nil`n    `n    // Check if user has UserStats resource`n    let userStatsResource = account.capabilities.get<&{Credit Predict.UserStatsPublic}>(`n        Credit Predict.UserStatsPublicPath`n    ).borrow()`n    let hasUserStatsResource = userStatsResource != nil`n    `n    // Get user profile details if available`n    var username: String? = nil`n    var displayName: String? = nil`n    var joinedAt: UFix64? = nil`n    `n    if let profile = userProfile {`n        username = profile.getUsername()`n        displayName = profile.getDisplayName()`n        joinedAt = profile.joinedAt`n    }`n    `n    // Determine overall registration status`n    let isFullyRegistered = isRegisteredInContract && hasUserProfile && hasUserPositions && hasUserStatsResource`n    `n    return {`n        "address": userAddress,`n        "isRegisteredInContract": isRegisteredInContract,`n        "hasUserProfile": hasUserProfile,`n        "hasUserPositions": hasUserPositions,`n        "hasUserStatsResource": hasUserStatsResource,`n        "isFullyRegistered": isFullyRegistered,`n        "username": username,`n        "displayName": displayName,`n        "joinedAt": joinedAt,`n        "userStats": userStats`n    }`n}`n`n// Simple version - just returns boolean`naccess(all) fun isUserRegistered(userAddress: Address): Bool {`n    let userStats = Credit Predict.getUserStats(address: userAddress)`n    let account = getAccount(userAddress)`n    let userProfile = account.capabilities.get<&{Credit Predict.UserProfilePublic}>(`n        Credit Predict.UserProfilePublicPath`n    ).borrow()`n    `n    return userStats != nil && userProfile != nil`n}`,`n`n  placeBet: ``n    import Credit Predict from ${getCredit PredictAddress()}`n    import FlowToken from ${getFlowTokenAddress()}`n    import FungibleToken from ${getFungibleTokenAddress()}`n`n     transaction(marketId: UInt64, option: UInt8, betAmount: UFix64) {`n        let betVault: @FlowToken.Vault`n        let userPositionsCap: Capability<&Credit Predict.UserPositions>`n        let signerAddress: Address`n`n        prepare(signer: auth(Storage, Capabilities, BorrowValue) &Account) {`n            self.signerAddress = signer.address`n            // Borrow FlowToken vault`n            let vault = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(`n                from: /storage/flowTokenVault`n            ) ?? panic("Could not borrow FlowToken vault")`n            `n            // Withdraw the bet amount`n            self.betVault <- vault.withdraw(amount: betAmount) as! @FlowToken.Vault`n`n            // Initialize UserPositions if not present`n            if !signer.storage.check<@Credit Predict.UserPositions>(from: Credit Predict.UserPositionsStoragePath) {`n                let userPositions <- Credit Predict.createUserPositions()`n                signer.storage.save(<-userPositions, to: Credit Predict.UserPositionsStoragePath)`n                signer.capabilities.publish(`n                    signer.capabilities.storage.issue<&{Credit Predict.UserPositionsPublic}>(Credit Predict.UserPositionsStoragePath),`n                    at: Credit Predict.UserPositionsPublicPath`n                )`n            }`n`n            // Get UserPositions capability from storage path`n            let storageCap = signer.capabilities.storage.issue<&Credit Predict.UserPositions>(Credit Predict.UserPositionsStoragePath)`n            self.userPositionsCap = storageCap`n            `n            // Verify UserPositions exists and check position limit`n            let userPositionsRef = signer.storage.borrow<&Credit Predict.UserPositions>(`n                from: Credit Predict.UserPositionsStoragePath`n            ) ?? panic("User positions resource not found for account")`n            `n            if !userPositionsRef.positions.containsKey(marketId) {`n                assert(`n                    UInt64(userPositionsRef.positions.length) < Credit Predict.maxPositionsPerUser,`n                    message: "User has reached the maximum number of distinct market positions"`n                )`n            }`n        }`n`n        execute {`n            // Create new position`n            let newPosition = Credit Predict.UserPosition(`n                marketId: marketId,`n                optionAShares: option == Credit Predict.MarketOutcome.OptionA.rawValue ? betAmount : 0.0,`n                optionBShares: option == Credit Predict.MarketOutcome.OptionB.rawValue ? betAmount : 0.0,`n                totalInvested: betAmount,`n                claimed: false`n            )`n`n            // Call placeBet with capability and position`n            Credit Predict.placeBet(`n                userAddress: self.signerAddress,`n                marketId: marketId,`n                option: option,`n                betVault: <-self.betVault,`n                userPositionsCap: self.userPositionsCap,`n                newPosition: newPosition`n            )`n`n            log("Bet placed successfully on market ".concat(marketId.toString()))`n            log("Bet amount: ".concat(betAmount.toString()).concat(" FLOW"))`n            log("Option selected: ".concat(option.toString()))`n        }`n    }`n  `,`n`n  getMarketEvidence: ``n    import Credit Predict from ${getCredit PredictAddress()}`n`naccess(all) fun main(marketId: UInt64): AnyStruct {`n    // First check if the market exists`n    let market = Credit Predict.getMarketById(marketId: marketId)`n    if market == nil {`n        return {`n            "success": false,`n            "error": "Market with ID ".concat(marketId.toString()).concat(" does not exist"),`n            "evidence": nil,`n            "marketInfo": nil`n        }`n    }`n    `n    // Get the resolution evidence`n    let evidence = Credit Predict.getResolutionEvidence(marketId: marketId)`n    `n    return {`n        "success": true,`n        "error": nil,`n        "evidence": evidence,`n        "marketInfo": {`n            "id": market!.id,`n            "title": market!.title,`n            "status": market!.status,`n            "resolved": market!.resolved,`n            "endTime": market!.endTime,`n            "creator": market!.creator`n        }`n    }`n}`n    `,`n  resolveMarket: ``n    import Credit Predict from ${getCredit PredictAddress()}`n`n    transaction(marketId: UInt64, outcome: UInt8, justification: String) {`n        prepare(signer: auth(Storage, Capabilities) &Account) {`n            Credit Predict.resolveMarket(`n                marketId: marketId,`n                outcome: outcome,`n                justification: justification`n            )`n        }`n`n        execute {`n            log("Market resolved successfully!")`n            log("Market ID: ".concat(marketId.toString()))`n            log("Outcome: ".concat(outcome.toString()))`n            log("Justification: ".concat(justification))`n        }`n    }`n  `,`n`n  claimWinnings: ``n    import Credit Predict from ${getCredit PredictAddress()}`n    import FlowToken from ${getFlowTokenAddress()}`n    import FungibleToken from ${getFungibleTokenAddress()}`n`n/// Transaction for a user to claim their winnings from a resolved market`n/// @param marketId: The ID of the market to claim winnings from`ntransaction(marketId: UInt64) {`n    let userPositionsCap: Capability<&Credit Predict.UserPositions>`n    let flowReceiver: &{FungibleToken.Receiver}`n    let signerAddress: Address`n    `n    prepare(signer: auth(Storage) &Account) {`n        // Store the signer's address for use in execute`n        self.signerAddress = signer.address`n        `n        // Get the UserPositions capability using Cadence 1.0 API`n        self.userPositionsCap = signer.capabilities.get<&Credit Predict.UserPositions>(Credit Predict.UserPositionsPublicPath)`n        `n        // Ensure the capability is valid`n        if !self.userPositionsCap.check() {`n            panic("UserPositions capability is not valid. User may not be properly initialized.")`n        }`n        `n        // Get the Flow token receiver capability using Cadence 1.0 API`n        self.flowReceiver = signer.capabilities.get<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)`n            .borrow()`n            ?? panic("Could not borrow Flow token receiver capability")`n    }`n    `n    execute {`n        // Claim the winnings`n        let winningsVault <- Credit Predict.claimWinnings(`n            marketId: marketId,`n            claimerAddress: self.signerAddress,`n            userPositionsCap: self.userPositionsCap`n        )`n        `n        // Deposit the winnings into the user's Flow vault`n        self.flowReceiver.deposit(from: <-winningsVault)`n        `n        log("Successfully claimed winnings for market ID: ".concat(marketId.toString()))`n    }`n}`n  `,`n`n  submitResolutionEvidence: ``n  import Credit Predict from ${getCredit PredictAddress()}`n`n  transaction(marketId: UInt64, evidence: String, requestedOutcome: UInt8) {`n      prepare(signer: auth(Storage, Capabilities) &Account) {`n          Credit Predict.submitResolutionEvidence(`n              address: signer.address,`n              marketId: marketId,`n              evidence: evidence,`n              requestedOutcome: requestedOutcome`n          )`n      }`n`n      execute {`n          log("Evidence submitted successfully")`n      }`n  }`n`,`n`n  withdrawPlatformFees: ``n    import Credit Predict from ${getCredit PredictAddress()}`n    import FlowToken from ${getFlowTokenAddress()}`n    import FungibleToken from ${getFungibleTokenAddress()}`n`n    transaction(amount: UFix64) {`n        prepare(signer: auth(Storage, Capabilities) &Account) {`n            let admin = signer.storage.borrow<&Credit Predict.Admin>(from: Credit Predict.AdminStoragePath)`n                ?? panic("Could not borrow Admin resource")`n            let vaultRef = signer.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)`n                ?? panic("Could not borrow reference to FlowToken Vault")`n            `n            let fees <- admin.withdrawPlatformFees(amount: amount)`n            vaultRef.deposit(from: <-fees)`n        }`n`n        execute {`n            log("Platform fees withdrawn successfully")`n        }`n    }`n  `,`n`n  withdrawAllPlatformFees: ``n    import Credit Predict from ${getCredit PredictAddress()}`n    import FlowToken from ${getFlowTokenAddress()}`n    import FungibleToken from ${getFungibleTokenAddress()}`n`n    transaction {`n        prepare(signer: auth(Storage, Capabilities) &Account) {`n            let admin = signer.storage.borrow<&Credit Predict.Admin>(from: Credit Predict.AdminStoragePath)`n                ?? panic("Could not borrow Admin resource")`n            let vaultRef = signer.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)`n                ?? panic("Could not borrow reference to FlowToken Vault")`n            `n            let fees <- admin.withdrawAllPlatformFees()`n            vaultRef.deposit(from: <-fees)`n        }`n`n        execute {`n            log("All platform fees withdrawn successfully")`n        }`n    }`n  `,`n`n  getPendingMarketDetails: ``n  import Credit Predict from ${getCredit PredictAddress()}`n`n  access(all) struct PendingMarketDetails {`n      access(all) let market: Credit Predict.Market`n      access(all) let evidence: Credit Predict.ResolutionEvidence?`n      access(all) let totalVolume: UFix64`n      access(all) let participantCount: UInt64`n      access(all) let daysSinceEnded: UFix64`n      access(all) let hasEvidence: Bool`n      `n      init(`n          market: Credit Predict.Market,`n          evidence: Credit Predict.ResolutionEvidence?,`n          totalVolume: UFix64,`n          participantCount: UInt64,`n          daysSinceEnded: UFix64,`n          hasEvidence: Bool`n      ) {`n          self.market = market`n          self.evidence = evidence`n          self.totalVolume = totalVolume`n          self.participantCount = participantCount`n          self.daysSinceEnded = daysSinceEnded`n          self.hasEvidence = hasEvidence`n      }`n  }`n`n  access(all) fun main(creatorAddress: Address): [PendingMarketDetails] {`n      let creatorMarkets = Credit Predict.getMarketsByCreator(creator: creatorAddress)`n      let pendingMarkets: [PendingMarketDetails] = []`n      let currentTime = getCurrentBlock().timestamp`n      `n      for market in creatorMarkets {`n          if market.status == Credit Predict.MarketStatus.PendingResolution {`n              let evidence = Credit Predict.getResolutionEvidence(marketId: market.id)`n              `n              let totalVolume = market.totalOptionAShares + market.totalOptionBShares`n              `n              let secondsSinceEnded = currentTime >= market.endTime ? currentTime - market.endTime : 0.0`n              let daysSinceEnded = secondsSinceEnded / 86400.0`n              `n              let participantCount = Credit Predict.getMarketParticipantCount(marketId: market.id)`n              `n              pendingMarkets.append(PendingMarketDetails(`n                  market: market,`n                  evidence: evidence,`n                  totalVolume: totalVolume,`n                  participantCount: participantCount,`n                  daysSinceEnded: daysSinceEnded,`n                  hasEvidence: evidence != nil`n              ))`n          }`n      }`n      `n      return pendingMarkets`n  }`n`,`n`n  getPendingMarketsBasic: ``n  import Credit Predict from ${getCredit PredictAddress()}`n`n  access(all) fun main(creatorAddress: Address): [Credit Predict.Market] {`n      let creatorMarkets = Credit Predict.getMarketsByCreator(creator: creatorAddress)`n      let pendingMarkets: [Credit Predict.Market] = []`n      `n      for market in creatorMarkets {`n          if market.status == Credit Predict.MarketStatus.PendingResolution {`n              pendingMarkets.append(market)`n          }`n      }`n      `n      return pendingMarkets`n  }`n`,`n`n  getPendingMarketsWithoutEvidence: ``n  import Credit Predict from ${getCredit PredictAddress()}`n`n  access(all) struct PendingMarketDetails {`n    access(all) let market: Credit Predict.Market`n    access(all) let evidence: Credit Predict.ResolutionEvidence?`n    access(all) let totalVolume: UFix64`n    access(all) let participantCount: UInt64`n    access(all) let daysSinceEnded: UFix64`n    access(all) let hasEvidence: Bool`n    `n    init(`n        market: Credit Predict.Market,`n        evidence: Credit Predict.ResolutionEvidence?,`n        totalVolume: UFix64,`n        participantCount: UInt64,`n        daysSinceEnded: UFix64,`n        hasEvidence: Bool`n    ) {`n        self.market = market`n        self.evidence = evidence`n        self.totalVolume = totalVolume`n        self.participantCount = participantCount`n        self.daysSinceEnded = daysSinceEnded`n        self.hasEvidence = hasEvidence`n    }`n}`n`n  access(all) fun main(creatorAddress: Address): [Credit Predict.Market] {`n    let creatorMarkets = Credit Predict.getMarketsByCreator(creator: creatorAddress)`n    let pendingWithoutEvidence: [Credit Predict.Market] = []`n    `n    for market in creatorMarkets {`n        if market.status == Credit Predict.MarketStatus.PendingResolution {`n            // Check if evidence does NOT exist for this market`n            if Credit Predict.getResolutionEvidence(marketId: market.id) == nil {`n                pendingWithoutEvidence.append(market)`n            }`n        }`n    }`n    `n    return pendingWithoutEvidence`n}`n`,`n`n  getAllPendingMarketsWithEvidence: ``n  import Credit Predict from ${getCredit PredictAddress()}`n  `n    access(all) struct PendingMarketDetails {`n    access(all) let market: Credit Predict.Market`n    access(all) let evidence: Credit Predict.ResolutionEvidence?`n    access(all) let totalVolume: UFix64`n    access(all) let participantCount: UInt64`n    access(all) let daysSinceEnded: UFix64`n    access(all) let hasEvidence: Bool`n    `n    init(`n        market: Credit Predict.Market,`n        evidence: Credit Predict.ResolutionEvidence?,`n        totalVolume: UFix64,`n        participantCount: UInt64,`n        daysSinceEnded: UFix64,`n        hasEvidence: Bool`n    ) {`n        self.market = market`n        self.evidence = evidence`n        self.totalVolume = totalVolume`n        self.participantCount = participantCount`n        self.daysSinceEnded = daysSinceEnded`n        self.hasEvidence = hasEvidence`n    }`n}`n`naccess(all) fun main(): [PendingMarketDetails] {`n    let allMarkets = Credit Predict.getPendingResolutionMarkets()`n    let pendingMarkets: [PendingMarketDetails] = []`n    let currentTime = getCurrentBlock().timestamp`n    `n    for market in allMarkets {`n        let evidence = Credit Predict.getResolutionEvidence(marketId: market.id)`n        if evidence != nil {`n            let totalVolume = market.totalOptionAShares + market.totalOptionBShares`n            let secondsSinceEnded = currentTime >= market.endTime ? currentTime - market.endTime : 0.0`n            let daysSinceEnded = secondsSinceEnded / 86400.0`n            let participantCount = Credit Predict.getMarketParticipantCount(marketId: market.id)`n            `n            pendingMarkets.append(PendingMarketDetails(`n                market: market,`n                evidence: evidence,`n                totalVolume: totalVolume,`n                participantCount: participantCount,`n                daysSinceEnded: daysSinceEnded,`n                hasEvidence: true`n            ))`n        }`n    }`n    `n    return pendingMarkets`n}`n `,`n`ngetAllUserTrades: ``nimport Credit Predict from ${getCredit PredictAddress()}`naccess(all) struct interface ActiveTradeInterface {`n    access(all) let marketId: UInt64`n    access(all) let marketTitle: String`n    access(all) let marketDescription: String`n    access(all) let optionA: String`n    access(all) let optionB: String`n    access(all) let optionAShares: UFix64`n    access(all) let optionBShares: UFix64`n    access(all) let totalInvested: UFix64`n    access(all) let averagePrice: UFix64`n    access(all) let endTime: UFix64`n    access(all) let currentValue: UFix64`n    access(all) let profitLoss: UFix64`n    access(all) let marketStatus: UInt8 // Added for debugging`n    access(all) let resolved: Bool // Added for debugging`n}`n`naccess(all) struct ActiveTrade: ActiveTradeInterface {`n    access(all) let marketId: UInt64`n    access(all) let marketTitle: String`n    access(all) let marketDescription: String`n    access(all) let optionA: String`n    access(all) let optionB: String`n    access(all) let optionAShares: UFix64`n    access(all) let optionBShares: UFix64`n    access(all) let totalInvested: UFix64`n    access(all) let averagePrice: UFix64`n    access(all) let endTime: UFix64`n    access(all) let currentValue: UFix64`n    access(all) let profitLoss: UFix64`n    access(all) let marketStatus: UInt8`n    access(all) let resolved: Bool`n`n    init(`n        marketId: UInt64,`n        marketTitle: String,`n        marketDescription: String,`n        optionA: String,`n        optionB: String,`n        optionAShares: UFix64,`n        optionBShares: UFix64,`n        totalInvested: UFix64,`n        averagePrice: UFix64,`n        endTime: UFix64,`n        currentValue: UFix64,`n        profitLoss: UFix64,`n        marketStatus: UInt8,`n        resolved: Bool`n    ) {`n        self.marketId = marketId`n        self.marketTitle = marketTitle`n        self.marketDescription = marketDescription`n        self.optionA = optionA`n        self.optionB = optionB`n        self.optionAShares = optionAShares`n        self.optionBShares = optionBShares`n        self.totalInvested = totalInvested`n        self.averagePrice = averagePrice`n        self.endTime = endTime`n        self.currentValue = currentValue`n        self.profitLoss = profitLoss`n        self.marketStatus = marketStatus`n        self.resolved = resolved`n    }`n}`n`naccess(all) fun main(userAddress: Address): {String: AnyStruct} {`n    let positions = Credit Predict.getUserPositions(address: userAddress)`n    let activeTrades: [ActiveTrade] = []`n    var totalDeposited: UFix64 = 0.0`n`n    for marketId in positions.keys {`n        let position = positions[marketId]!`n        if let market = Credit Predict.getMarketById(marketId: marketId) {`n            // Include Active and PendingResolution markets`n            if !market.resolved && (market.status == Credit Predict.MarketStatus.Active || market.status == Credit Predict.MarketStatus.PendingResolution) {`n                let totalShares = position.optionAShares + position.optionBShares`n                let currentValue = totalShares // Simplified: assumes 1:1 share value`n                let profitLoss: UFix64 = currentValue >= position.totalInvested`n                    ? currentValue - position.totalInvested`n                    : position.totalInvested - currentValue`n                activeTrades.append(ActiveTrade(`n                    marketId: marketId,`n                    marketTitle: market.title,`n                    marketDescription: market.description,`n                    optionA: market.optionA,`n                    optionB: market.optionB,`n                    optionAShares: position.optionAShares,`n                    optionBShares: position.optionBShares,`n                    totalInvested: position.totalInvested,`n                    averagePrice: position.averagePrice,`n                    endTime: market.endTime,`n                    currentValue: currentValue,`n                    profitLoss: profitLoss,`n                    marketStatus: market.status.rawValue,`n                    resolved: market.resolved`n                ))`n                totalDeposited = totalDeposited + position.totalInvested`n            }`n        }`n    }`n`n    return {`n        "activeTrades": activeTrades as [AnyStruct],`n        "totalDeposited": totalDeposited as AnyStruct`n    }`n}`n`,`n};`n`nexport class Credit PredictScripts {`n  private static cache: Map<string, string> = new Map();`n`n  static async getScript(scriptName: string): Promise<string> {`n    if (this.cache.has(scriptName)) {`n      return this.cache.get(scriptName)!;`n    }`n`n    if (scriptName in CADENCE_SCRIPTS) {`n      const script =`n        CADENCE_SCRIPTS[scriptName as keyof typeof CADENCE_SCRIPTS];`n      this.cache.set(scriptName, script);`n      return script;`n    }`n`n    throw new Error(`Credit Predict script not found: ${scriptName}`);`n  }`n`n  static async getTransaction(transactionName: string): Promise<string> {`n    return this.getScript(transactionName);`n  }`n`n  static async getQuery(queryName: string): Promise<string> {`n    return this.getScript(queryName);`n  }`n`n  static clearCache(): void {`n    this.cache.clear();`n  }`n}`n`nexport const getScript = Credit PredictScripts.getScript.bind(Credit PredictScripts);`nexport const getTransaction =`n  Credit PredictScripts.getTransaction.bind(Credit PredictScripts);`nexport const getQuery = Credit PredictScripts.getQuery.bind(Credit PredictScripts);`n`nexport const getActiveMarkets = () =>`n  Credit PredictScripts.getScript("getActiveMarkets");`nexport const getAllMarkets = () => Credit PredictScripts.getScript("getAllMarkets");`nexport const getMarketById = () => Credit PredictScripts.getScript("getMarketById");`nexport const getMarketCreator = () =>`n  Credit PredictScripts.getScript("getMarketByCreator");`nexport const getPlatformStats = () =>`n  Credit PredictScripts.getScript("getPlatformStats");`nexport const getUserFlowBalance = () =>`n  Credit PredictScripts.getScript("getUserFlowBalance");`nexport const getUserProfile = () =>`n  Credit PredictScripts.getScript("getUserProfile");`nexport const getPendingMarkets = () =>`n  Credit PredictScripts.getScript("getPendingMarkets");`nexport const getPendingMarketsWithEvidence = () =>`n  Credit PredictScripts.getScript("getPendingMarketsWithEvidence");`nexport const getUserPositions = () =>`n  Credit PredictScripts.getScript("getUserPositions");`nexport const getUserDashboardData = () =>`n  Credit PredictScripts.getScript("getUserDashboardData");`nexport const getActiveUserPositions = () =>`n  Credit PredictScripts.getScript("activeUserPositions");`nexport const getClaimableWinnings = () =>`n  Credit PredictScripts.getScript("getClaimableWinnings");`nexport const checkUserRegistered = () =>`n  Credit PredictScripts.getScript("checkUserRegistered");`nexport const getUserTrades = () => Credit PredictScripts.getScript("getUserTrades");`nexport const getPendingMarketDetails = () =>`n  Credit PredictScripts.getScript("getPendingMarketDetails");`nexport const getPendingMarketsBasic = () =>`n  Credit PredictScripts.getScript("getPendingMarketsBasic");`nexport const getAllPendingMarketsWithEvidence = () =>`n  Credit PredictScripts.getScript("getAllPendingMarketsWithEvidence");`nexport const getPendingMarketsWithoutEvidence = () =>`n  Credit PredictScripts.getScript("getPendingMarketsWithoutEvidence");`nexport const getAllPendingMarkets = () =>`n  Credit PredictScripts.getScript("getAllPendingMarkets");`nexport const getMarketEvidence = () =>`n  Credit PredictScripts.getScript("getMarketEvidence");`nexport const getAllUserTrades = ()=>  Credit PredictScripts.getScript("getAllUserTrades");`n`n// export const submitResolutionEvidenceTransaction = () => Credit PredictScripts.getTransaction("submitResolutionEvidence");`n// export const checkUsernameAvailability = () =>`n//   Credit PredictScripts.getScript("checkUsernameAvailability");`n`nexport const createUserAccountTransaction = () =>`n  Credit PredictScripts.getTransaction("createUserAccount");`nexport const createMarketTransaction = () =>`n  Credit PredictScripts.getTransaction("createMarket");`nexport const placeBetTransaction = () =>`n  Credit PredictScripts.getTransaction("placeBet");`nexport const resolveMarketTransaction = () =>`n  Credit PredictScripts.getTransaction("resolveMarket");`nexport const claimWinningsTransaction = () =>`n  Credit PredictScripts.getTransaction("claimWinnings");`nexport const submitResolutionEvidenceTransaction = () =>`n  Credit PredictScripts.getTransaction("submitResolutionEvidence");`nexport const withdrawPlatformFeesTransaction = () =>`n  Credit PredictScripts.getTransaction("withdrawPlatformFees");`nexport const withdrawAllPlatformFeesTransaction = () =>`n  Credit PredictScripts.getTransaction("withdrawAllPlatformFees");`n`nexport type ScriptName = keyof typeof CADENCE_SCRIPTS;`n`nexport type TransactionName =`n  | "createUserAccount"`n  | "createMarket"`n  | "placeBet"`n  | "resolveMarket"`n  | "claimWinnings"`n  | "submitResolutionEvidence"`n  | "withdrawPlatformFees"`n  | "withdrawAllPlatformFees"`n  | "checkUserRegistered"`n  | "checkUsernameAvailability";`n`nexport type QueryName =`n  | "getPendingMarketDetails"`n  | "getPendingMarketsBasic"`n  | "getPendingMarketsWithEvidence"`n  | "getPendingMarketsWithoutEvidence"`n  | "getActiveMarkets"`n  | "getAllMarkets"`n  | "getMarketById"`n  | "getMarketCreator"`n  | "getPlatformStats"`n  | "getUserFlowBalance"`n  | "getUserProfile"`n  | "getPendingMarkets"`n  | "getUserPositions"`n  | "getUserDashboardData"`n  | "activeUserPositions"`n  | "getClaimableWinnings"`n  | "checkUserRegistered"`n  | "checkUsernameAvailability"`n  | "getUserTrades";