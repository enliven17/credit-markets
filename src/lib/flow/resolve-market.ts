// This file contains backend Cadence script/transaction generators and does not render any UI.`n// Mobile responsiveness should be implemented in the React components/pages that use these scripts.`n// No changes needed for mobile responsiveness here.`n/* eslint-disable @typescript-eslint/no-explicit-any */`n// lib/resolution-scripts.ts`nimport type { MarketOutcome } from "@/types/market";`n`nconst Credit Predict_CONTRACT = process.env.NEXT_PUBLIC_Credit Predict_CONTRACT;`n`n// TypeScript interfaces for script arguments and returns`ninterface ScriptDefinition {`n    cadence: string;`n    args: Array<{ value: any; type: string }>;`n}`n`ninterface TransactionDefinition {`n    cadence: string;`n    args: Array<{ value: any; type: string }>;`n    limit: number;`n}`n`n// =====================================`n// RESOLUTION SCRIPTS`n// =====================================`n`n// Get markets pending resolution (ended but not resolved)`nexport const GET_PENDING_MARKETS = ``nimport Credit Predict from ${Credit Predict_CONTRACT}`n`naccess(all) fun main(): [Credit Predict.Market] {`n    let allMarkets = Credit Predict.getAllMarkets()`n    let pendingMarkets: [Credit Predict.Market] = []`n    let currentTime = getCurrentBlock().timestamp`n`n    for market in allMarkets {`n        if market.endTime < currentTime && !market.resolved && market.status == Credit Predict.MarketStatus.Active {`n            pendingMarkets.append(market)`n        }`n    }`n`n    return pendingMarkets`n}`n`;`n`n// Check if user has admin privileges`nexport const CHECK_ADMIN_PRIVILEGES = ``nimport Credit Predict from ${Credit Predict_CONTRACT}`n`naccess(all) fun main(userAddress: Address): Bool {`n    let account = getAccount(userAddress)`n    return account.storage.borrow<&Credit Predict.Admin>(from: /storage/Credit PredictAdmin) != nil`n}`n`;`n`n// =====================================`n// RESOLUTION TRANSACTIONS`n// =====================================`n`n// Resolve market transaction (matching your pattern)`nexport const RESOLVE_MARKET_TRANSACTION = ``nimport Credit Predict from ${Credit Predict_CONTRACT}`n`ntransaction(marketId: UInt64, outcome: UInt8) {`n    let adminRef: &Credit Predict.Admin`n    `n    prepare(signer: auth(BorrowValue) &Account) {`n        // Get reference to Admin resource`n        self.adminRef = signer.storage.borrow<&Credit Predict.Admin>(from: /storage/Credit PredictAdmin)`n            ?? panic("Could not borrow Admin reference")`n    }`n    `n    execute {`n        // Convert UInt8 to MarketOutcome enum`n        let outcomeEnum = Credit Predict.MarketOutcome(rawValue: outcome)`n            ?? panic("Invalid outcome value")`n        `n        // Resolve the market`n        self.adminRef.resolveMarket(marketId: marketId, outcome: outcomeEnum)`n        `n        log("Market resolved with outcome: ".concat(outcome.toString()))`n    }`n}`n`;`n`n// =====================================`n// SCRIPT GENERATORS`n// =====================================`n`nexport const getPendingMarketsScript = (): ScriptDefinition => {`n    return {`n        cadence: GET_PENDING_MARKETS,`n        args: [],`n    };`n};`n`nexport const getMarketByIdScript = (marketId: string | number): ScriptDefinition => {`n    return {`n        cadence: ``n            import Credit Predict from ${Credit Predict_CONTRACT}`n            `n            access(all) fun main(marketId: UInt64): Credit Predict.Market? {`n                return Credit Predict.getMarket(marketId: marketId)`n            }`n        `,`n        args: [{ value: marketId.toString(), type: "UInt64" }],`n    };`n};`n`nexport const checkAdminPrivilegesScript = (userAddress: string): ScriptDefinition => {`n    return {`n        cadence: CHECK_ADMIN_PRIVILEGES,`n        args: [{ value: userAddress, type: "Address" }],`n    };`n};`n`n// Updated to match your transaction pattern`nexport const resolveMarketTransaction = (`n    marketId: number, `n    outcome: MarketOutcome`n): TransactionDefinition => {`n    return {`n        cadence: RESOLVE_MARKET_TRANSACTION,`n        args: [`n            { value: marketId, type: "UInt64" },`n            { value: outcome, type: "UInt8" }`n        ],`n        limit: 100`n    };`n};`n`n// Additional transaction generators to match your existing patterns`n`nexport const createMarketTransaction = (`n    title: string,`n    description: string,`n    category: number,`n    optionA: string,`n    optionB: string,`n    endTime: number,`n    minBet: number,`n    maxBet: number`n): TransactionDefinition => {`n    return {`n        cadence: ``n            import Credit Predict from ${Credit Predict_CONTRACT}`n`n            transaction(`n                title: String,`n                description: String,`n                category: UInt8,`n                optionA: String,`n                optionB: String,`n                endTime: UFix64,`n                minBet: UFix64,`n                maxBet: UFix64`n            ) {`n                let adminRef: &Credit Predict.Admin`n                `n                prepare(signer: auth(BorrowValue) &Account) {`n                    // Get reference to Admin resource`n                    self.adminRef = signer.storage.borrow<&Credit Predict.Admin>(from: /storage/Credit PredictAdmin)`n                        ?? panic("Could not borrow Admin reference")`n                }`n                `n                execute {`n                    let marketId = self.adminRef.createMarket(`n                        title: title,`n                        description: description,`n                        category: Credit Predict.MarketCategory(rawValue: category)!,`n                        optionA: optionA,`n                        optionB: optionB,`n                        endTime: endTime,`n                        minBet: minBet,`n                        maxBet: maxBet`n                    )`n                    `n                    log("Market created with ID: ".concat(marketId.toString()))`n                }`n            }`n        `,`n        args: [`n            { value: title, type: "String" },`n            { value: description, type: "String" },`n            { value: category, type: "UInt8" },`n            { value: optionA, type: "String" },`n            { value: optionB, type: "String" },`n            { value: endTime.toFixed(1), type: "UFix64" },`n            { value: minBet.toFixed(8), type: "UFix64" },`n            { value: maxBet.toFixed(8), type: "UFix64" }`n        ],`n        limit: 150`n    };`n};`n`nexport const buySharesTransaction = (`n    marketId: number,`n    isOptionA: boolean,`n    amount: number`n): TransactionDefinition => {`n    return {`n        cadence: ``n            import Credit Predict from ${Credit Predict_CONTRACT}`n            import FlowToken from 0x1654653399040a61`n            import FungibleToken from 0xf233dcee88fe0abe`n`n            transaction(marketId: UInt64, option: UInt8, amount: UFix64) {`n                let flowVault: &FlowToken.Vault`n                `n                prepare(signer: auth(BorrowValue) &Account) {`n                    // Get reference to signer's FlowToken vault`n                    self.flowVault = signer.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)`n                        ?? panic("Could not borrow FlowToken vault reference")`n                }`n                `n                execute {`n                    // Call the contract function to buy shares`n                    Credit Predict.buyShares(marketId: marketId, option: option, amount: amount)`n                    `n                    log("Shares purchased for market: ".concat(marketId.toString()))`n                }`n            }`n        `,`n        args: [`n            { value: marketId, type: "UInt64" },`n            { value: isOptionA ? 1 : 2, type: "UInt8" },`n            { value: amount.toFixed(8), type: "UFix64" }`n        ],`n        limit: 100`n    };`n};`n`nexport const claimWinningsTransaction = (marketId: number): TransactionDefinition => {`n    return {`n        cadence: ``n            import Credit Predict from ${Credit Predict_CONTRACT}`n            import FungibleToken from 0xf233dcee88fe0abe`n            import FlowToken from 0x1654653399040a61`n            `n            transaction(marketId: UInt64) {`n                let signerVault: &FlowToken.Vault`n                `n                prepare(signer: auth(BorrowValue) &Account) {`n                    self.signerVault = signer.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)`n                        ?? panic("Could not borrow FlowToken.Vault reference")`n                }`n                `n                execute {`n                    let winningsVault <- Credit Predict.claimWinnings(marketId: marketId)`n                    self.signerVault.deposit(from: <-winningsVault)`n                    `n                    log("Winnings claimed for market: ".concat(marketId.toString()))`n                }`n            }`n        `,`n        args: [`n            { value: marketId, type: "UInt64" }`n        ],`n        limit: 100`n    };`n};`n`n// Export types`nexport type { ScriptDefinition, TransactionDefinition };