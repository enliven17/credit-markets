export const buySharesTransaction = (`n  marketId: number, `n  isOptionA: boolean, `n  amount: number`n) => {`n  // This would use @onflow/fcl in a real implementation`n  return {`n    cadence: ``n      import Credit Predict from 0xCredit Predict`n      import FlowToken from 0x1654653399040a61`n      import FungibleToken from 0xf233dcee88fe0abe`n`n      transaction(marketId: UInt64, option: UInt8, amount: UFix64) {`n        let flowVault: &FlowToken.Vault`n        `n        prepare(signer: AuthAccount) {`n          // Get reference to signer's FlowToken vault`n          self.flowVault = signer.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)`n            ?? panic("Could not borrow FlowToken vault reference")`n        }`n        `n        execute {`n          // Call the contract function to buy shares`n          Credit Predict.buyShares(marketId: marketId, option: option, amount: amount)`n        }`n      }`n    `,`n    args: [`n      { value: marketId, type: 'UInt64' },`n      { value: isOptionA ? 1 : 2, type: 'UInt8' },`n      { value: amount.toFixed(8), type: 'UFix64' }`n    ],`n    limit: 100`n  };`n};`n`nexport const createMarketTransaction = (`n  question: string,`n  optionA: string,`n  optionB: string,`n  category: string,`n  imageURI: string,`n  duration: number,`n  isBreakingNews: boolean`n) => {`n  return {`n    cadence: ``n      import Credit Predict from 0xCredit Predict`n`n      transaction(`n        title: String,`n        description: String,`n        category: UInt8,`n        optionA: String,`n        optionB: String,`n        endTime: UFix64,`n        minBet: UFix64,`n        maxBet: UFix64`n      ) {`n        let adminRef: &Credit Predict.Admin`n        `n        prepare(signer: AuthAccount) {`n          // Get reference to Admin resource`n          self.adminRef = signer.borrow<&Credit Predict.Admin>(from: /storage/Credit PredictAdmin)`n            ?? panic("Could not borrow Admin reference")`n        }`n        `n        execute {`n          let marketId = self.adminRef.createMarket(`n            title: title,`n            description: description,`n            category: Credit Predict.MarketCategory(rawValue: category)!,`n            optionA: optionA,`n            optionB: optionB,`n            endTime: endTime,`n            minBet: minBet,`n            maxBet: maxBet`n          )`n        }`n      }`n    `,`n    args: [`n      { value: question, type: 'String' },`n      { value: optionA, type: 'String' },`n      { value: optionB, type: 'String' },`n      { value: 0, type: 'UInt8' }, // Category enum value`n      { value: imageURI, type: 'String' },`n      { value: (duration * 3600.0).toFixed(1), type: 'UFix64' }, // Convert hours to seconds`n      { value: isBreakingNews, type: 'Bool' }`n    ],`n    limit: 150`n  };`n};`n`nexport const resolveMarketTransaction = (marketId: number, outcome: string) => {`n  const outcomeValue = outcome === 'OPTION_A' ? 1 : 2;`n  `n  return {`n    cadence: ``n      import Credit Predict from 0xCredit Predict_ADDRESS`n      `n      transaction(marketId: UInt64, outcome: UInt8) {`n        let adminRef: &Credit Predict.Admin`n        `n        prepare(signer: AuthAccount) {`n          self.adminRef = signer.borrow<&Credit Predict.Admin>(from: Credit Predict.AdminStoragePath)`n            ?? panic("Could not borrow Admin reference")`n        }`n        `n        execute {`n          let outcomeEnum = Credit Predict.MarketOutcome(rawValue: outcome)!`n          self.adminRef.resolveMarket(marketId: marketId, outcome: outcomeEnum)`n          `n          log("Market resolved with outcome: ".concat(outcome.toString()))`n        }`n      }`n    `,`n    args: [`n      { value: marketId, type: 'UInt64' },`n      { value: outcomeValue, type: 'UInt8' }`n    ],`n    limit: 100`n  };`n};`n`nexport const claimWinningsTransaction = (marketId: number) => {`n  return {`n    cadence: ``n      import Credit Predict from 0xCredit Predict_ADDRESS`n      import FungibleToken from 0xFUNGIBLE_TOKEN_ADDRESS`n      import FlowToken from 0xFLOW_TOKEN_ADDRESS`n      `n      transaction(marketId: UInt64) {`n        let signerVault: &FlowToken.Vault`n        `n        prepare(signer: AuthAccount) {`n          self.signerVault = signer.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)`n            ?? panic("Could not borrow FlowToken.Vault reference")`n        }`n        `n        execute {`n          let winningsVault <- Credit Predict.claimWinnings(marketId: marketId)`n          self.signerVault.deposit(from: <-winningsVault)`n          `n          log("Winnings claimed for market: ".concat(marketId.toString()))`n        }`n      }`n    `,`n    args: [`n      { value: marketId, type: 'UInt64' }`n    ],`n    limit: 100`n  };`n};