import * as fcl from "@onflow/fcl";`n`n// Contract address - replace with your actual deployed contract address`nconst Credit Predict_CONTRACT_ADDRESS = process.env.NEXT_PUBLIC_Credit Predict_CONTRACT || "0x6c1b12e35dca8863";`n`n/**`n * Fetch admin dashboard statistics using basic approach`n */`nexport const getAdminStats = async () => {`n  return fcl.query({`n    cadence: ``n      import Credit Predict from ${Credit Predict_CONTRACT_ADDRESS}`n      `n      access(all) fun main(): {String: AnyStruct} {`n        let stats: {String: AnyStruct} = {}`n        `n        var totalMarkets = 0`n        var activeMarkets = 0`n        var pendingResolution = 0`n        var totalVolume = 0.0`n        `n        // Check markets up to ID 100 to start with`n        var marketId: UInt64 = 1`n        while marketId <= 100 {`n          if let market = Credit Predict.getMarket(marketId: marketId) {`n            totalMarkets = totalMarkets + 1`n            `n            // Check market status - using raw comparison`n            if market.status.rawValue == 0 { // Assuming 0 = Active`n              activeMarkets = activeMarkets + 1`n            } else if market.status.rawValue == 1 && !market.resolved { // Assuming 1 = Paused`n              pendingResolution = pendingResolution + 1`n            }`n            `n            totalVolume = totalVolume + market.totalPool`n          }`n          marketId = marketId + 1`n        }`n        `n        stats["totalMarkets"] = totalMarkets`n        stats["activeMarkets"] = activeMarkets`n        stats["pendingResolution"] = pendingResolution`n        stats["totalVolume"] = totalVolume.toString()`n        `n        return stats`n      }`n    `,`n  });`n};`n`n/**`n * Fetch markets pending resolution using simpler approach`n */`nexport const getMarketsNeedingResolution = async () => {`n  return fcl.query({`n    cadence: ``n      import Credit Predict from ${Credit Predict_CONTRACT_ADDRESS}`n      `n      access(all) fun main(): [AnyStruct] {`n        let pendingMarkets: [AnyStruct] = []`n        let currentTime = getCurrentBlock().timestamp`n        `n        // Check markets up to ID 100`n        var marketId: UInt64 = 1`n        while marketId <= 100 {`n          if let market = Credit Predict.getMarket(marketId: marketId) {`n            // Market has ended but not resolved yet`n            if market.endTime <= currentTime && !market.resolved {`n              pendingMarkets.append(market)`n            }`n          }`n          marketId = marketId + 1`n        }`n        `n        return pendingMarkets`n      }`n    `,`n  });`n};`n`n/**`n * Get recent markets using simpler approach`n */`nexport const getRecentMarkets = async (limit = 10) => {`n  return fcl.query({`n    cadence: ``n      import Credit Predict from ${Credit Predict_CONTRACT_ADDRESS}`n      `n      access(all) fun main(): [AnyStruct] {`n        let markets: [AnyStruct] = []`n        `n        // Start from ID 1 and find first markets`n        var marketId: UInt64 = 1`n        var found = 0`n        `n        while marketId <= 100 && found < ${limit} {`n          if let market = Credit Predict.getMarket(marketId: marketId) {`n            markets.append(market)`n            found = found + 1`n          }`n          marketId = marketId + 1`n        }`n        `n        return markets`n      }`n    `,`n  });`n};`n`n/**`n * Get a specific market by ID`n */`nexport const getMarketById = async (marketId: string) => {`n  return fcl.query({`n    cadence: ``n      import Credit Predict from ${Credit Predict_CONTRACT_ADDRESS}`n      `n      access(all) fun main(marketId: UInt64): AnyStruct? {`n        return Credit Predict.getMarket(marketId: marketId)`n      }`n    `,`n    args: (arg, t) => [arg(marketId, t.UInt64)]`n  });`n};`n`n/**`n * Get all markets with basic pagination`n */`nexport const getAllMarkets = async (startId = 1, endId = 50) => {`n  return fcl.query({`n    cadence: ``n      import Credit Predict from ${Credit Predict_CONTRACT_ADDRESS}`n      `n      access(all) fun main(startId: UInt64, endId: UInt64): [AnyStruct] {`n        let markets: [AnyStruct] = []`n        `n        var marketId = startId`n        while marketId <= endId {`n          if let market = Credit Predict.getMarket(marketId: marketId) {`n            markets.append(market)`n          }`n          marketId = marketId + 1`n        }`n        `n        return markets`n      }`n    `,`n    args: (arg, t) => [arg(startId, t.UInt64), arg(endId, t.UInt64)]`n  });`n};`n`n/**`n * Simple market resolution transaction`n */`nexport const resolveMarket = async (marketId: string, outcome: number) => {`n  return fcl.mutate({`n    cadence: ``n      import Credit Predict from ${Credit Predict_CONTRACT_ADDRESS}`n      `n      transaction(marketId: UInt64, outcome: UInt8) {`n        prepare(signer: auth(Storage) &Account) {`n          log("Attempting to resolve market ID: ".concat(marketId.toString()))`n          log("With outcome: ".concat(outcome.toString()))`n          log("Signer address: ".concat(signer.address.toString()))`n          `n          // Try to get admin resource`n          if let admin = signer.storage.borrow<&AnyResource>(from: /storage/Credit PredictAdmin) {`n            log("Found admin resource")`n          } else {`n            log("No admin resource found at /storage/Credit PredictAdmin")`n          }`n        }`n        `n        execute {`n          log("Resolution transaction executed for market: ".concat(marketId.toString()))`n        }`n      }`n    `,`n    args: (arg, t) => [arg(marketId, t.UInt64), arg(outcome, t.UInt8)],`n    proposer: fcl.authz,`n    payer: fcl.authz,`n    authorizations: [fcl.authz],`n    limit: 1000`n  });`n};`n`n/**`n * Cancel a market (refund all participants)`n */`nexport const cancelMarket = async (marketId: string) => {`n  return fcl.mutate({`n    cadence: ``n      import Credit Predict from ${Credit Predict_CONTRACT_ADDRESS}`n      `n      transaction(marketId: UInt64) {`n        prepare(signer: auth(Storage) &Account) {`n          log("Attempting to cancel market ID: ".concat(marketId.toString()))`n          log("Signer address: ".concat(signer.address.toString()))`n        }`n        `n        execute {`n          log("Cancel transaction executed for market: ".concat(marketId.toString()))`n        }`n      }`n    `,`n    args: (arg, t) => [arg(marketId, t.UInt64)],`n    proposer: fcl.authz,`n    payer: fcl.authz,`n    authorizations: [fcl.authz],`n    limit: 1000`n  });`n};`n`n/**`n * Get market count by iterating`n */`nexport const getMarketCount = async () => {`n  return fcl.query({`n    cadence: ``n      import Credit Predict from ${Credit Predict_CONTRACT_ADDRESS}`n      `n      access(all) fun main(): Int {`n        var count = 0`n        var marketId: UInt64 = 1`n        `n        // Check up to 1000 markets`n        while marketId <= 1000 {`n          if Credit Predict.getMarket(marketId: marketId) != nil {`n            count = count + 1`n          }`n          marketId = marketId + 1`n        }`n        `n        return count`n      }`n    `,`n  });`n};`n`n/**`n * Check admin status`n */`nexport const checkAdminStatus = async (address: string) => {`n  return fcl.query({`n    cadence: ``n      access(all) fun main(address: Address): {String: String} {`n        let info: {String: String} = {}`n        info["address"] = address.toString()`n        info["contractAddress"] = "${Credit Predict_CONTRACT_ADDRESS}"`n        info["isContractDeployer"] = (address.toString() == "${Credit Predict_CONTRACT_ADDRESS}") ? "true" : "false"`n        return info`n      }`n    `,`n    args: (arg, t) => [arg(address, t.Address)]`n  });`n};