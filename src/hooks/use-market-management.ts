/* eslint-disable @typescript-eslint/no-explicit-any */`n"use client"`n`nimport { useState, useEffect, useMemo } from 'react';`nimport * as fcl from '@onflow/fcl';`nimport flowConfig from '@/lib/flow/config';`nimport { Market, MarketCategory, MarketStatus, PlatformStats } from '@/types/market';`nimport { `n  getAllMarkets,`n  getPlatformStats,`n} from '@/lib/flow-wager-scripts';`n`nexport function useMarketManagement() {`n  // State with proper types`n  const [markets, setMarkets] = useState<Market[]>([]);`n  const [loading, setLoading] = useState(true);`n  const [error, setError] = useState<string | null>(null);`n  const [platformStats, setPlatformStats] = useState<PlatformStats | null>(null);`n`n  // Filter states with proper types - default to 'active' instead of 'all'`n  const [searchQuery, setSearchQuery] = useState('');`n  const [activeTab, setActiveTab] = useState<string>('active');`n  const [showFilters, setShowFilters] = useState(false);`n  const [sortBy, setSortBy] = useState<'newest' | 'ending' | 'volume' | 'popular'>('newest');`n  const [selectedCategory, setSelectedCategory] = useState<'all' | MarketCategory>('all');`n  const [selectedStatus, setSelectedStatus] = useState<'all' | MarketStatus>('all');`n`n  // Initialize Flow configuration`n  const initConfig = async () => {`n    try {`n      flowConfig();`n      `n      // Debug: Log configuration status`n      console.log('Flow configuration initialized:', {`n        network: process.env.NEXT_PUBLIC_FLOW_NETWORK || 'testnet',`n        Credit PredictContract: process.env.NEXT_PUBLIC_Credit Predict_TESTNET_CONTRACT,`n        accessNode: process.env.NEXT_PUBLIC_FLOW_ACCESS_API,`n        discoveryWallet: process.env.NEXT_PUBLIC_FLOW_DISCOVERY_WALLET`n      });`n    } catch (error) {`n      console.error('Failed to initialize Flow configuration:', error);`n      throw error;`n    }`n  };`n`n  // Fetch markets from smart contract`n  const fetchMarkets = async () => {`n    try {`n      setLoading(true);`n      setError(null);`n`n      // Initialize Flow configuration before making queries`n      await initConfig();`n`n      // Fetch all markets using your script`n      const getAllMarketsScript = await getAllMarkets();`n      const contractMarkets = await fcl.query({`n        cadence: getAllMarketsScript,`n      });`n`n      console.log('Raw contract markets:', contractMarkets);`n`n      // Transform contract data to Market interface`n      const transformedMarkets: Market[] = contractMarkets?.map((market: any) => ({`n        id: market.id.toString(),`n        title: market.title,`n        description: market.description,`n        category: parseInt(market.category.rawValue),`n        optionA: market.optionA,`n        optionB: market.optionB,`n        creator: market.creator,`n        createdAt: market.createdAt.toString(),`n        endTime: market.endTime.toString(),`n        minBet: market.minBet.toString(),`n        maxBet: market.maxBet.toString(),`n        status: parseInt(market.status.rawValue),`n        outcome: market.outcome ? parseInt(market.outcome.rawValue) : undefined,`n        resolved: market.resolved,`n        totalOptionAShares: market.totalOptionAShares.toString(),`n        totalOptionBShares: market.totalOptionBShares.toString(),`n        totalPool: market.totalPool.toString(),`n        imageUrl: market.imageUrl || ""`n      })) || [];`n`n      console.log('Transformed markets:', transformedMarkets);`n      setMarkets(transformedMarkets);`n`n      // Fetch platform stats using your script`n      const getPlatformStatsScript = await getPlatformStats();`n      const stats = await fcl.query({`n        cadence: getPlatformStatsScript,`n      });`n`n      console.log('Raw platform stats:', stats);`n`n      setPlatformStats({`n        totalMarkets: parseInt(stats.totalMarkets.toString()),`n        activeMarkets: parseInt(stats.activeMarkets.toString()),`n        totalUsers: parseInt(stats.totalUsers.toString()),`n        totalVolume: stats.totalVolume.toString(),`n        totalFees: stats.totalFees.toString()`n      });`n`n    } catch (err) {`n      console.error('Error fetching markets from smart contract:', err);`n      `n      // Enhanced error handling`n      if (err instanceof Error) {`n        if (err.message.includes('accessNode.api')) {`n          setError('Flow network configuration error. Please check environment variables.');`n        } else if (err.message.includes('script not found')) {`n          setError('Contract script error. Please verify contract deployment.');`n        } else if (err.message.includes('location')) {`n          setError('Contract address error. Please check NEXT_PUBLIC_Credit Predict_TESTNET_CONTRACT.');`n        } else {`n          setError(`Blockchain error: ${err.message}`);`n        }`n      } else {`n        setError('Failed to fetch markets from blockchain');`n      }`n    } finally {`n      setLoading(false);`n    }`n  };`n`n  // Fetch active markets only (more efficient for dashboard)`n  const fetchActiveMarkets = async () => {`n    try {`n      setLoading(true);`n      setError(null);`n`n      await initConfig();`n`n      // Use getActiveMarkets for better performance if you only need active markets`n      const { getActiveMarkets } = await import('@/lib/flow-wager-scripts');`n      const getActiveMarketsScript = await getActiveMarkets();`n      `n      const contractMarkets = await fcl.query({`n        cadence: getActiveMarketsScript,`n      });`n`n      const transformedMarkets: Market[] = contractMarkets?.map((market: any) => ({`n        id: market.id.toString(),`n        title: market.title,`n        description: market.description,`n        category: parseInt(market.category.rawValue),`n        optionA: market.optionA,`n        optionB: market.optionB,`n        creator: market.creator,`n        createdAt: market.createdAt.toString(),`n        endTime: market.endTime.toString(),`n        minBet: market.minBet.toString(),`n        maxBet: market.maxBet.toString(),`n        status: parseInt(market.status.rawValue),`n        outcome: market.outcome ? parseInt(market.outcome.rawValue) : undefined,`n        resolved: market.resolved,`n        totalOptionAShares: market.totalOptionAShares.toString(),`n        totalOptionBShares: market.totalOptionBShares.toString(),`n        totalPool: market.totalPool.toString(),`n        imageUrl: market.imageUrl || ""`n      })) || [];`n`n      setMarkets(transformedMarkets);`n`n    } catch (err) {`n      console.error('Error fetching active markets:', err);`n      setError(err instanceof Error ? err.message : 'Failed to fetch active markets');`n    } finally {`n      setLoading(false);`n    }`n  };`n`n  // Filter and sort markets`n  const filteredAndSortedMarkets = useMemo(() => {`n    let filtered = markets;`n    const now = Date.now() / 1000;`n`n    // Search filter`n    if (searchQuery) {`n      filtered = filtered.filter(market =>`n        market.title.toLowerCase().includes(searchQuery.toLowerCase()) ||`n        market.description.toLowerCase().includes(searchQuery.toLowerCase()) ||`n        market.optionA.toLowerCase().includes(searchQuery.toLowerCase()) ||`n        market.optionB.toLowerCase().includes(searchQuery.toLowerCase())`n      );`n    }`n`n    // Tab filter - Updated logic`n    switch (activeTab) {`n      case 'active':`n        // Markets that are currently active (not ended and not resolved)`n        filtered = filtered.filter(market => `n          market.status === MarketStatus.Active && `n          parseFloat(market.endTime) > now`n        );`n        break;`n      case 'pending':`n        // Markets that have ended but not yet resolved`n        filtered = filtered.filter(market => `n          market.status === MarketStatus.Active && `n          parseFloat(market.endTime) <= now`n        );`n        break;`n      case 'resolved':`n        // Markets that have been resolved`n        filtered = filtered.filter(market => market.status === MarketStatus.Resolved);`n        break;`n      case 'trending':`n        // Popular active markets (currently running with volume)`n        filtered = filtered.filter(market => `n          market.status === MarketStatus.Active && `n          parseFloat(market.endTime) > now &&`n          parseFloat(market.totalPool) > 0`n        ).sort((a, b) => parseFloat(b.totalPool) - parseFloat(a.totalPool));`n        break;`n    }`n`n    // Category filter`n    if (selectedCategory !== 'all') {`n      filtered = filtered.filter(market => market.category === selectedCategory);`n    }`n`n    // Status filter`n    if (selectedStatus !== 'all') {`n      filtered = filtered.filter(market => market.status === selectedStatus);`n    }`n`n    // Sort (skip for trending as it's already sorted by volume)`n    if (activeTab !== 'trending') {`n      filtered.sort((a, b) => {`n        switch (sortBy) {`n          case 'newest':`n            return parseFloat(b.createdAt) - parseFloat(a.createdAt);`n          case 'ending':`n            return parseFloat(a.endTime) - parseFloat(b.endTime);`n          case 'volume':`n            return parseFloat(b.totalPool) - parseFloat(a.totalPool);`n          case 'popular':`n            const aShares = parseFloat(a.totalOptionAShares) + parseFloat(a.totalOptionBShares);`n            const bShares = parseFloat(b.totalOptionAShares) + parseFloat(b.totalOptionBShares);`n            return bShares - aShares;`n          default:`n            return 0;`n        }`n      });`n    }`n`n    return filtered;`n  }, [markets, searchQuery, activeTab, selectedCategory, selectedStatus, sortBy]);`n`n  // Calculate market counts - Updated logic`n  const marketCounts = useMemo(() => {`n    const now = Date.now() / 1000;`n    `n    return {`n      active: markets.filter(m => `n        m.status === MarketStatus.Active && `n        parseFloat(m.endTime) > now`n      ).length,`n      pending: markets.filter(m => `n        m.status === MarketStatus.Active && `n        parseFloat(m.endTime) <= now`n      ).length,`n      resolved: markets.filter(m => m.status === MarketStatus.Resolved).length,`n      trending: markets.filter(m => `n        m.status === MarketStatus.Active && `n        parseFloat(m.endTime) > now &&`n        parseFloat(m.totalPool) > 0`n      ).length`n    };`n  }, [markets]);`n`n  // Calculate market stats`n  const marketStats = useMemo(() => {`n    const now = Date.now() / 1000;`n    const activeMarkets = markets.filter(m => `n      m.status === MarketStatus.Active && `n      parseFloat(m.endTime) > now`n    );`n    const totalVolume = markets.reduce((sum, m) => sum + parseFloat(m.totalPool || '0'), 0);`n    const avgVolume = markets.length > 0 ? totalVolume / markets.length : 0;`n    `n    const pendingMarkets = markets.filter(m => `n      m.status === MarketStatus.Active && `n      parseFloat(m.endTime) <= now`n    ).length;`n`n    return {`n      active: activeMarkets.length,`n      totalVolume,`n      avgVolume,`n      endingSoon: pendingMarkets // Now represents pending markets`n    };`n  }, [markets]);`n`n  // Type-safe filter handlers`n  const handleCategoryChange = (category: 'all' | MarketCategory) => {`n    setSelectedCategory(category);`n  };`n`n  const handleStatusChange = (status: 'all' | MarketStatus) => {`n    setSelectedStatus(status);`n  };`n`n  // Reset filters`n  const handleResetFilters = () => {`n    setSearchQuery('');`n    setSelectedCategory('all');`n    setSelectedStatus('all');`n    setSortBy('newest');`n    setActiveTab('active'); // Default to active instead of all`n  };`n`n  // Fetch data on mount and setup interval for real-time updates`n  useEffect(() => {`n    fetchMarkets();`n  }, []);`n`n  return {`n    // Data`n    markets,`n    filteredAndSortedMarkets,`n    marketStats,`n    marketCounts,`n    platformStats,`n    loading,`n    error,`n    `n    // Filter states`n    searchQuery,`n    activeTab,`n    showFilters,`n    sortBy,`n    selectedCategory,`n    selectedStatus,`n    `n    // Filter setters`n    setSearchQuery,`n    setActiveTab,`n    setShowFilters,`n    setSortBy,`n    handleCategoryChange,`n    handleStatusChange,`n    `n    // Actions`n    refetch: fetchMarkets,`n    fetchActiveMarkets, // New method for better performance`n    handleResetFilters`n  };`n}